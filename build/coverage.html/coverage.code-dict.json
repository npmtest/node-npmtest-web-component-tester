{"/home/travis/build/npmtest/node-npmtest-web-component-tester/test.js":"/* istanbul instrument in package npmtest_web_component_tester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/lib.npmtest_web_component_tester.js":"/* istanbul instrument in package npmtest_web_component_tester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_web_component_tester = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_web_component_tester = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-web-component-tester && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_web_component_tester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_web_component_tester\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_web_component_tester.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_web_component_tester.rollup.js'] =\n            local.assetsDict['/assets.npmtest_web_component_tester.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_web_component_tester.__dirname + '/lib.npmtest_web_component_tester.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nmodule.exports = {\n  cli:    require('./runner/cli'),\n  config: require('./runner/config'),\n  gulp:   require('./runner/gulp'),\n  steps:  require('./runner/steps'),\n  test:   require('./runner/test'),\n};\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/cli.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk = require(\"chalk\");\nconst events = require(\"events\");\nconst _ = require(\"lodash\");\nconst clireporter_1 = require(\"./clireporter\");\nconst config = require(\"./config\");\nconst context_1 = require(\"./context\");\nconst plugin_1 = require(\"./plugin\");\nconst test_1 = require(\"./test\");\nconst PACKAGE_INFO = require('../package.json');\nconst noopNotifier = {\n    notify: () => { }\n};\nlet updateNotifier = noopNotifier;\n(function () {\n    try {\n        updateNotifier = require('update-notifier')({ pkg: PACKAGE_INFO });\n    }\n    catch (error) {\n        // S'ok if we don't have update-notifier. It's optional.\n    }\n})();\nfunction run(env, args, output) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield wrapResult(output, _run(args, output));\n    });\n}\nexports.run = run;\nfunction _run(args, output) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Options parsing is a two phase affair. First, we need an initial set of\n        // configuration so that we know which plugins to load, etc:\n        let options = config.preparseArgs(args);\n        // Depends on values from the initial merge:\n        options = config.merge(options, {\n            output: output,\n            ttyOutput: !process.env.CI && output['isTTY'] && !options.simpleOutput,\n        });\n        const context = new context_1.Context(options);\n        if (options.skipUpdateCheck) {\n            updateNotifier = noopNotifier;\n        }\n        // `parseArgs` merges any new configuration into `context.options`.\n        yield config.parseArgs(context, args);\n        yield test_1.test(context);\n    });\n}\n// Note that we're cheating horribly here. Ideally all of this logic is within\n// wct-sauce. The trouble is that we also want WCT's configuration lookup logic,\n// and that's not (yet) cleanly exposed.\nfunction runSauceTunnel(env, args, output) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield wrapResult(output, _runSauceTunnel(args, output));\n    });\n}\nexports.runSauceTunnel = runSauceTunnel;\nfunction _runSauceTunnel(args, output) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const diskOptions = config.fromDisk();\n        const baseOptions = (diskOptions.plugins && diskOptions.plugins['sauce']) ||\n            diskOptions.sauce || {};\n        const plugin = yield plugin_1.Plugin.get('sauce');\n        const parser = require('nomnom');\n        parser.script('wct-st');\n        parser.options(_.omit(plugin.cliConfig, 'browsers', 'tunnelId'));\n        const options = _.merge(baseOptions, parser.parse(args));\n        const wctSauce = require('wct-sauce');\n        wctSauce.expandOptions(options);\n        const emitter = new events.EventEmitter();\n        new clireporter_1.CliReporter(emitter, output, {});\n        const tunnelId = yield new Promise((resolve, reject) => {\n            wctSauce.startTunnel(options, emitter, (error, tunnelId) => error ? reject(error) : resolve(tunnelId));\n        });\n        output.write('\\n');\n        output.write('The tunnel will remain active while this process is running.\\n');\n        output.write('To use this tunnel for other WCT runs, export the following:\\n');\n        output.write('\\n');\n        output.write(chalk.cyan('export SAUCE_TUNNEL_ID=' + tunnelId) + '\\n');\n    });\n}\nfunction wrapResult(output, promise) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let error;\n        try {\n            yield promise;\n        }\n        catch (e) {\n            error = e;\n        }\n        if (!process.env.CI) {\n            updateNotifier.notify();\n        }\n        if (error) {\n            output.write('\\n');\n            output.write(chalk.red(error) + '\\n');\n            output.write('\\n');\n            throw error;\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/clireporter.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk = require(\"chalk\");\nconst cleankill = require(\"cleankill\");\nconst _ = require(\"lodash\");\nconst stacky = require(\"stacky\");\nconst util = require(\"util\");\nconst STACKY_CONFIG = {\n    indent: '    ',\n    locationStrip: [\n        /^https?:\\/\\/[^\\/]+/,\n        /\\?[\\d\\.]+$/,\n    ],\n    unimportantLocation: [\n        /^\\/web-component-tester\\//,\n    ]\n};\nconst STATE_ICONS = {\n    passing: '✓',\n    pending: '✖',\n    failing: '✖',\n    unknown: '?',\n};\nconst STATE_COLORS = {\n    passing: chalk.green,\n    pending: chalk.yellow,\n    failing: chalk.red,\n    unknown: chalk.red,\n    error: chalk.red,\n};\nconst SHORT = {\n    'internet explorer': 'IE',\n};\nconst BROWSER_PAD = 24;\nconst STATUS_PAD = 38;\nclass CliReporter {\n    constructor(emitter, stream, options) {\n        this.prettyBrowsers = {};\n        this.browserStats = {};\n        this.emitter = emitter;\n        this.stream = stream;\n        this.options = options;\n        cleankill.onInterrupt((done) => {\n            this.flush();\n            done();\n        });\n        emitter.on('log:error', this.log.bind(this, chalk.red));\n        if (!this.options.quiet) {\n            emitter.on('log:warn', this.log.bind(this, chalk.yellow));\n            emitter.on('log:info', this.log.bind(this));\n            if (this.options.verbose) {\n                emitter.on('log:debug', this.log.bind(this, chalk.dim));\n            }\n        }\n        emitter.on('browser-init', (browser, stats) => {\n            this.browserStats[browser.id] = stats;\n            this.prettyBrowsers[browser.id] = this.prettyBrowser(browser);\n            this.updateStatus();\n        });\n        emitter.on('browser-start', (browser, data, stats) => {\n            this.browserStats[browser.id] = stats;\n            this.log(browser, 'Beginning tests via', chalk.magenta(data.url));\n            this.updateStatus();\n        });\n        emitter.on('test-end', (browser, data, stats) => {\n            this.browserStats[browser.id] = stats;\n            if (data.state === 'failing') {\n                this.writeTestError(browser, data);\n            }\n            else if (this.options.expanded || this.options.verbose) {\n                this.log(browser, this.stateIcon(data.state), this.prettyTest(data));\n            }\n            this.updateStatus();\n        });\n        emitter.on('browser-end', (browser, error, stats) => {\n            this.browserStats[browser.id] = stats;\n            if (error) {\n                this.log(chalk.red, browser, 'Tests failed:', error);\n            }\n            else {\n                this.log(chalk.green, browser, 'Tests passed');\n            }\n        });\n        emitter.on('run-end', (error) => {\n            if (error) {\n                this.log(chalk.red, 'Test run ended in failure:', error);\n            }\n            else {\n                this.log(chalk.green, 'Test run ended with great success');\n            }\n            if (!this.options.ttyOutput) {\n                this.updateStatus(true);\n            }\n        });\n    }\n    // Specialized Reporting\n    updateStatus(force) {\n        if (!this.options.ttyOutput && !force) {\n            return;\n        }\n        // EXTREME TERMINOLOGY FAIL, but here's a glossary:\n        //\n        // stats:  An object containing test stats (total, passing, failing, etc).\n        // state:  The state that the run is in (running, etc).\n        // status: A string representation of above.\n        const statuses = Object.keys(this.browserStats).map((browserIdStr) => {\n            const browserId = parseInt(browserIdStr, 10);\n            const pretty = this.prettyBrowsers[browserId];\n            const stats = this.browserStats[browserId];\n            let status = '';\n            const counts = [stats.passing, stats.pending, stats.failing];\n            if (counts[0] > 0 || counts[1] > 0 || counts[2] > 0) {\n                if (counts[0] > 0) {\n                    counts[0] = chalk.green(counts[0].toString());\n                }\n                if (counts[1] > 0) {\n                    counts[1] = chalk.yellow(counts[1].toString());\n                }\n                if (counts[2] > 0) {\n                    counts[2] = chalk.red(counts[2].toString());\n                }\n                status = counts.join('/');\n            }\n            if (stats.status === 'error') {\n                status = status + (status === '' ? '' : ' ') + chalk.red('error');\n            }\n            return padRight(pretty + ' (' + status + ')', STATUS_PAD);\n        });\n        this.writeWrapped(statuses, '  ');\n    }\n    ;\n    writeTestError(browser, data) {\n        this.log(browser, this.stateIcon(data.state), this.prettyTest(data));\n        const error = data.error || {};\n        this.write('\\n');\n        let prettyMessage = error.message || error;\n        if (typeof prettyMessage !== 'string') {\n            prettyMessage = util.inspect(prettyMessage);\n        }\n        this.write(chalk.red('  ' + prettyMessage));\n        if (error.stack) {\n            try {\n                this.write(stacky.pretty(data.error.stack, STACKY_CONFIG));\n            }\n            catch (err) {\n                // If we couldn't extract a stack (i.e. there was no stack), the message\n                // is enough.\n            }\n        }\n        this.write('\\n');\n    }\n    ;\n    // Object Formatting\n    stateIcon(state) {\n        const color = STATE_COLORS[state] || STATE_COLORS['unknown'];\n        return color(STATE_ICONS[state] || STATE_ICONS.unknown);\n    }\n    ;\n    prettyTest(data) {\n        const color = STATE_COLORS[data.state] || STATE_COLORS['unknown'];\n        return color(data.test.join(' » ') || '<unknown test>');\n    }\n    ;\n    prettyBrowser(browser) {\n        const parts = [];\n        if (browser.platform && !browser.deviceName) {\n            parts.push(browser.platform);\n        }\n        const name = browser.deviceName || browser.browserName;\n        parts.push(SHORT[name] || name);\n        if (browser.version) {\n            parts.push(browser.version);\n        }\n        return chalk.blue(parts.join(' '));\n    }\n    ;\n    log() {\n        let values = Array.from(arguments);\n        let format;\n        if (_.isFunction(values[0])) {\n            format = values[0];\n            values = values.slice(1);\n        }\n        if (values[0] && values[0].browserName) {\n            values[0] = padRight(this.prettyBrowser(values[0]), BROWSER_PAD);\n        }\n        let line = _.toArray(values)\n            .map((value) => _.isString(value) ? value : util.inspect(value))\n            .join(' ');\n        line = line.replace(/[\\s\\n\\r]+$/, '');\n        if (format) {\n            line = format(line);\n        }\n        this.write(line);\n    }\n    ;\n    writeWrapped(blocks, separator) {\n        if (blocks.length === 0) {\n            return;\n        }\n        const lines = [''];\n        const width = this.stream.columns || 0;\n        for (const block of blocks) {\n            const line = lines[lines.length - 1];\n            const combined = line + separator + block;\n            if (line === '') {\n                lines[lines.length - 1] = block;\n            }\n            else if (chalk.stripColor(combined).length <= width) {\n                lines[lines.length - 1] = combined;\n            }\n            else {\n                lines.push(block);\n            }\n        }\n        this.writeLines(['\\n'].concat(lines));\n        if (this.options.ttyOutput) {\n            this.stream.write('\\r');\n            this.stream.write('\\u001b[' + (lines.length + 1) + 'A');\n        }\n    }\n    ;\n    write(line) {\n        this.writeLines([line]);\n        this.updateStatus();\n    }\n    ;\n    writeLines(lines) {\n        for (let line of lines) {\n            if (line[line.length - 1] !== '\\n') {\n                line = line + '\\n';\n            }\n            if (this.options.ttyOutput) {\n                line = '\\u001b[J' + line;\n            }\n            this.stream.write(line);\n        }\n        this.linesWritten = lines.length;\n    }\n    ;\n    flush() {\n        if (!this.options.ttyOutput) {\n            return;\n        }\n        // Add an extra line for padding.\n        for (let i = 0; i <= this.linesWritten; i++) {\n            this.stream.write('\\n');\n        }\n    }\n    ;\n}\n// HACK\nCliReporter.CliReporter = CliReporter;\nexports.CliReporter = CliReporter;\n// Yeah, yeah.\nfunction padRight(str, length) {\n    let currLength = chalk.stripColor(str).length;\n    while (currLength < length) {\n        currLength = currLength + 1;\n        str = str + ' ';\n    }\n    return str;\n}\nmodule.exports = CliReporter;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/config.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst findup = require(\"findup-sync\");\nconst fs = require(\"fs\");\nconst _ = require(\"lodash\");\nconst nomnom = require(\"nomnom\");\nconst path = require(\"path\");\nconst serveWaterfall = require(\"serve-waterfall\");\nconst paths = require(\"./paths\");\nconst HOME_DIR = path.resolve(process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE);\nconst JSON_MATCHER = 'wct.conf.json';\nconst CONFIG_MATCHER = 'wct.conf.*';\nconst WCT_ROOT = path.resolve(__dirname, '..');\n// The full set of options, as a reference.\nfunction defaults() {\n    return {\n        // The test suites that should be run.\n        suites: ['test/'],\n        // Output stream to write log messages to.\n        output: process.stdout,\n        // Whether the output stream should be treated as a TTY (and be given more\n        // complex output formatting). Defaults to `output.isTTY`.\n        ttyOutput: undefined,\n        // Spew all sorts of debugging messages.\n        verbose: false,\n        // Silence output\n        quiet: false,\n        // Display test results in expanded form. Verbose implies expanded.\n        expanded: false,\n        // The on-disk path where tests & static files should be served from. Paths\n        // (such as `suites`) are evaluated relative to this.\n        //\n        // Defaults to the project directory.\n        root: undefined,\n        // Idle timeout for tests.\n        testTimeout: 90 * 1000,\n        // Whether the browser should be closed after the tests run.\n        persistent: false,\n        // Additional .js files to include in *generated* test indexes.\n        extraScripts: [],\n        // Configuration options passed to the browser client.\n        clientOptions: {\n            // Also see `webserver.pathMappings` below.\n            root: '/components/',\n        },\n        // Webdriver capabilities objects for each browser that should be run.\n        //\n        // Capabilities can also contain a `url` value which is either a string URL\n        // for the webdriver endpoint, or {hostname:, port:, user:, pwd:}.\n        //\n        // Most of the time you will want to rely on the WCT browser plugins to fill\n        // this in for you (e.g. via `--local`, `--sauce`, etc).\n        activeBrowsers: [],\n        // Default capabilities to use when constructing webdriver connections (for\n        // each browser specified in `activeBrowsers`). A handy place to hang common\n        // configuration.\n        //\n        // Selenium: https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities\n        // Sauce:    https://docs.saucelabs.com/reference/test-configuration/\n        browserOptions: {},\n        // The plugins that should be loaded, and their configuration.\n        //\n        // When an array, the named plugins will be loaded with their default\n        // configuration. When an object, each key maps to a plugin, and values are\n        // configuration values to be merged.\n        //\n        //   plugins: {\n        //     local: {browsers: ['firefox', 'chrome']},\n        //   }\n        //\n        plugins: ['local', 'sauce'],\n        // Callback that allows you to perform advanced configuration of the WCT\n        // runner.\n        //\n        // The hook is given the WCT context, and can generally be written like a\n        // plugin. For example, to serve custom content via the internal webserver:\n        //\n        //     registerHooks: function(wct) {\n        //       wct.hook('prepare:webserver', function(app) {\n        //         app.use(...);\n        //         return Promise.resolve();\n        //       });\n        //     }\n        //\n        registerHooks: function (wct) { },\n        // Whether `wct.conf.*` is allowed, or only `wct.conf.json`.\n        //\n        // Handy for CI suites that want to be locked down.\n        enforceJsonConf: false,\n        // Configuration options for the webserver that serves up your test files\n        // and dependencies.\n        //\n        // Typically, you will not need to modify these values.\n        webserver: {\n            // The port that the webserver should run on. A port will be determined at\n            // runtime if none is provided.\n            port: undefined,\n            // The hostname used when generating URLs for the webdriver client.\n            hostname: 'localhost',\n            // mappings of URL prefix to on disk paths that the web server should\n            // serve via https://github.com/PolymerLabs/serve-waterfall\n            pathMappings: serveWaterfall.mappings.WEB_COMPONENT.concat([\n                // We also expose built in WCT dependencies, but with lower priority\n                // than the project's components.\n                {\n                    '/components/sinonjs': path.join(WCT_ROOT, 'node_modules', 'sinon', 'pkg')\n                },\n                {\n                    '/components/lodash/lodash.js': path.join(WCT_ROOT, 'node_modules', 'lodash', 'index.js')\n                },\n                { '/components': path.join(WCT_ROOT, 'node_modules') },\n                // npm 3 paths\n                { '/components/sinonjs': path.join(WCT_ROOT, '..', 'sinon', 'pkg') }, {\n                    '/components/lodash/lodash.js': path.join(WCT_ROOT, '..', 'lodash', 'index.js')\n                },\n                { '/components/': path.join(WCT_ROOT, '..') }\n            ]),\n            // The URL prefix that serves contents from the project root.\n            urlPrefix: '/components/<basename>',\n        },\n    };\n}\nexports.defaults = defaults;\n/** nomnom configuration for command line arguments.\n *\n * This might feel like duplication with `defaults()`, and out of place (why not\n * in `cli.js`?). But, not every option matches a configurable value, and it is\n * best to keep the configuration for these together to help keep them in sync.\n */\nconst ARG_CONFIG = {\n    persistent: {\n        help: 'Keep browsers active (refresh to rerun tests).',\n        abbr: 'p',\n        flag: true,\n    },\n    root: {\n        help: 'The root directory to serve tests from.',\n        transform: path.resolve,\n    },\n    plugins: {\n        help: 'Plugins that should be loaded.',\n        metavar: 'NAME',\n        full: 'plugin',\n        list: true,\n    },\n    skipPlugins: {\n        help: 'Configured plugins that should _not_ be loaded.',\n        metavar: 'NAME',\n        full: 'skip-plugin',\n        list: true,\n    },\n    expanded: {\n        help: 'Log a status line for each test run.',\n        flag: true,\n    },\n    verbose: {\n        help: 'Turn on debugging output.',\n        flag: true,\n    },\n    quiet: {\n        help: 'Silence output.',\n        flag: true,\n    },\n    simpleOutput: {\n        help: 'Avoid fancy terminal output.',\n        flag: true,\n    },\n    skipUpdateCheck: {\n        help: 'Don\\'t check for updates.',\n        full: 'skip-update-check',\n        flag: true,\n    },\n    'webserver.port': {\n        help: 'A port to use for the test webserver.',\n        full: 'webserver-port',\n    },\n    'webserver.hostname': {\n        full: 'webserver-hostname',\n        hidden: true,\n    },\n    // Managed by supports-color; let's not freak out if we see it.\n    color: { flag: true },\n    // Deprecated\n    browsers: {\n        abbr: 'b',\n        hidden: true,\n        list: true,\n    },\n    remote: {\n        abbr: 'r',\n        hidden: true,\n        flag: true,\n    },\n};\n// Values that should be extracted when pre-parsing args.\nconst PREPARSE_ARGS = ['plugins', 'skipPlugins', 'simpleOutput', 'skipUpdateCheck'];\n/**\n * Discovers appropriate config files (global, and for the project), merging\n * them, and returning them.\n *\n * @param {boolean} jsonOnly\n * @param {string} root\n * @return {!Object} The merged configuration.\n */\nfunction fromDisk(jsonOnly, root) {\n    const matcher = jsonOnly ? JSON_MATCHER : CONFIG_MATCHER;\n    const globalFile = path.join(HOME_DIR, matcher);\n    const projectFile = findup(matcher, { nocase: true, cwd: root });\n    // Load a shared config from the user's home dir, if they have one, and then\n    // try the project-specific path (starting at the current working directory).\n    const paths = _.union([globalFile, projectFile]);\n    const configs = _.filter(paths, fs.existsSync).map(loadProjectFile);\n    const options = merge.apply(null, configs);\n    if (!options.root && projectFile && projectFile !== globalFile) {\n        options.root = path.dirname(projectFile);\n    }\n    return options;\n}\nexports.fromDisk = fromDisk;\n/**\n * @param {string} file\n * @return {Object?}\n */\nfunction loadProjectFile(file) {\n    // If there are _multiple_ configs at this path, prefer `json`\n    if (path.extname(file) === '.js' && fs.existsSync(file + 'on')) {\n        file = file + 'on';\n    }\n    try {\n        if (path.extname(file) === '.json') {\n            return JSON.parse(fs.readFileSync(file, 'utf-8'));\n        }\n        else {\n            return require(file);\n        }\n    }\n    catch (error) {\n        throw new Error(`Failed to load WCT config \"${file}\": ' + error.message`);\n    }\n}\n/**\n * Runs a simplified options parse over the command line arguments, extracting\n * any values that are necessary for a full parse.\n *\n * At the moment, the only values extracted are `--plugin` and `--simpleOutput`.\n *\n * @param {!Array<string>} args\n * @return {!Object}\n */\nfunction preparseArgs(args) {\n    // Don't let it short circuit on help.\n    args = _.difference(args, ['--help', '-h']);\n    const parser = nomnom();\n    parser.options(ARG_CONFIG);\n    parser.printer(function () { }); // No-op output & errors.\n    const options = parser.parse(args);\n    return _expandOptionPaths(_.pick(options, PREPARSE_ARGS));\n}\nexports.preparseArgs = preparseArgs;\n/**\n * Runs a complete options parse over the args, respecting plugin options.\n *\n * @param {!Context} context The context, containing plugin state and any base\n *     options to merge into.\n * @param {!Array<string>} args The args to parse.\n */\nfunction parseArgs(context, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const parser = nomnom();\n        parser.script('wct');\n        parser.options(ARG_CONFIG);\n        const plugins = yield context.plugins();\n        plugins.forEach(_configurePluginOptions.bind(null, parser));\n        const options = _expandOptionPaths(normalize(parser.parse(args)));\n        if (options._ && options._.length > 0) {\n            options.suites = options._;\n        }\n        context.options = merge(context.options, options);\n    });\n}\nexports.parseArgs = parseArgs;\nfunction _configurePluginOptions(parser, plugin) {\n    /** HACK(rictic): this looks wrong, cliConfig shouldn't have a length. */\n    if (!plugin.cliConfig || plugin.cliConfig.length === 0) {\n        return;\n    }\n    // Group options per plugin. It'd be nice to also have a header, but that ends\n    // up shifting all the options over.\n    parser.option('plugins.' + plugin.name + '.', { string: ' ' });\n    _.each(plugin.cliConfig, function (config, key) {\n        // Make sure that we don't expose the name prefixes.\n        if (!config.full) {\n            config.full = key;\n        }\n        parser.option('plugins.' + plugin.name + '.' + key, config);\n    });\n}\nfunction _expandOptionPaths(options) {\n    const result = {};\n    _.each(options, function (value, key) {\n        let target = result;\n        const parts = key.split('.');\n        for (const part of parts.slice(0, -1)) {\n            target = target[part] = target[part] || {};\n        }\n        target[_.last(parts)] = value;\n    });\n    return result;\n}\nfunction merge() {\n    let configs = Array.prototype.slice.call(arguments);\n    const result = {};\n    configs = configs.map(normalize);\n    _.merge.apply(_, [result].concat(configs));\n    // false plugin configs are preserved.\n    configs.forEach(function (config) {\n        _.each(config.plugins, function (value, key) {\n            if (value === false) {\n                result.plugins[key] = false;\n            }\n        });\n    });\n    return result;\n}\nexports.merge = merge;\nfunction normalize(config) {\n    if (_.isArray(config.plugins)) {\n        const pluginConfigs = {};\n        for (let i = 0, name; name = config.plugins[i]; i++) {\n            // A named plugin is explicitly enabled (e.g. --plugin foo).\n            pluginConfigs[name] = { disabled: false };\n        }\n        config.plugins = pluginConfigs;\n    }\n    // Always wins.\n    if (config.skipPlugins) {\n        config.plugins = config.plugins || {};\n        for (let i = 0, name; name = config.skipPlugins[i]; i++) {\n            config.plugins[name] = false;\n        }\n    }\n    return config;\n}\nexports.normalize = normalize;\n/**\n * Expands values within the configuration based on the current environment.\n *\n * @param {!Context} context The context for the current run.\n */\nfunction expand(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const options = context.options;\n        let root = context.options.root || process.cwd();\n        context.options.root = root = path.resolve(root);\n        options.origSuites = _.clone(options.suites);\n        expandDeprecated(context);\n        options.suites = yield paths.expand(root, options.suites);\n    });\n}\nexports.expand = expand;\n/**\n * Expands any options that have been deprecated, and warns about it.\n *\n * @param {!Context} context The context for the current run.\n */\nfunction expandDeprecated(context) {\n    const options = context.options;\n    // We collect configuration fragments to be merged into the options object.\n    const fragments = [];\n    let browsers = (_.isArray(options.browsers) ? options.browsers : [options.browsers]);\n    browsers = _.compact(browsers);\n    if (browsers.length > 0) {\n        context.emit('log:warn', 'The --browsers flag/option is deprecated. Please use ' +\n            '--local and --sauce instead, or configure via plugins.' +\n            '[local|sauce].browsers.');\n        const fragment = {\n            plugins: { sauce: {}, local: {} }\n        };\n        fragments.push(fragment);\n        for (const browser of browsers) {\n            const name = browser.browserName || browser;\n            const plugin = browser.platform || name.indexOf('/') !== -1 ?\n                'sauce' :\n                'local';\n            fragment.plugins[plugin].browsers =\n                fragment.plugins[plugin].browsers || [];\n            fragment.plugins[plugin].browsers.push(browser);\n        }\n        delete options.browsers;\n    }\n    if (options.sauce) {\n        context.emit('log:warn', 'The sauce configuration key is deprecated. Please use ' +\n            'plugins.sauce instead.');\n        fragments.push({\n            plugins: { sauce: options.sauce },\n        });\n        delete options.sauce;\n    }\n    if (options.remote) {\n        context.emit('log:warn', 'The --remote flag is deprecated. Please use ' +\n            '--sauce default instead.');\n        fragments.push({\n            plugins: { sauce: { browsers: ['default'] } },\n        });\n        delete options.remote;\n    }\n    if (fragments.length > 0) {\n        // We are careful to modify context.options in place.\n        _.merge(context.options, merge.apply(null, fragments));\n    }\n}\n/**\n * @param {!Object} options The configuration to validate.\n */\nfunction validate(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options['webRunner']) {\n            throw new Error('webRunner is no longer a supported configuration option. ' +\n                'Please list the files you wish to test as arguments, ' +\n                'or as `suites` in a configuration object.');\n        }\n        if (options['component']) {\n            throw new Error('component is no longer a supported configuration option. ' +\n                'Please list the files you wish to test as arguments, ' +\n                'or as `suites` in a configuration object.');\n        }\n        if (options.activeBrowsers.length === 0) {\n            throw new Error('No browsers configured to run');\n        }\n        if (options.suites.length === 0) {\n            const root = options.root || process.cwd();\n            const globs = options.origSuites.join(', ');\n            throw new Error('No test suites were found matching your configuration\\n' +\n                '\\n' +\n                '  WCT searched for .js and .html files matching: ' + globs + '\\n' +\n                '\\n' +\n                '  Relative paths were resolved against: ' + root);\n        }\n    });\n}\nexports.validate = validate;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/paths.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst glob = require(\"glob\");\nconst _ = require(\"lodash\");\nconst path = require(\"path\");\nconst promisify = require(\"promisify-node\");\n/**\n * Expands a series of path patterns (globs, files, directories) into a set of\n * files that represent those patterns.\n *\n * @param baseDir The directory that patterns are relative to.\n * @param patterns The patterns to expand.\n * @returns The expanded paths.\n */\nfunction expand(baseDir, patterns) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return expandDirectories(baseDir, yield unglob(baseDir, patterns));\n    });\n}\nexports.expand = expand;\n/**\n * Expands any glob expressions in `patterns`.\n */\nfunction unglob(baseDir, patterns) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const strs = [];\n        const pGlob = promisify(glob);\n        for (const pattern of patterns) {\n            strs.push(yield pGlob(String(pattern), { cwd: baseDir, root: baseDir }));\n        }\n        return _.union(_.flatten(strs));\n    });\n}\n/**\n * Expands any directories in `patterns`, following logic similar to a web\n * server.\n *\n * If a pattern resolves to a directory, that directory is expanded. If the\n * directory contains an `index.html`, it is expanded to that. Otheriwse, the\n * it expands into its children (recursively).\n */\nfunction expandDirectories(baseDir, paths) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const listsOfPaths = [];\n        for (const aPath of paths) {\n            listsOfPaths.push(yield expandDirectory(baseDir, aPath));\n        }\n        const files = _.union(_.flatten(listsOfPaths));\n        return files.filter((file) => /\\.(js|html)$/.test(file));\n    });\n}\nfunction expandDirectory(baseDir, aPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stat = yield promisify(fs.stat)(path.resolve(baseDir, aPath));\n        if (!stat.isDirectory()) {\n            return [aPath];\n        }\n        const files = yield promisify(fs.readdir)(path.resolve(baseDir, aPath));\n        // We have an index; defer to that.\n        if (_.includes(files, 'index.html')) {\n            return [path.join(aPath, 'index.html')];\n        }\n        const children = yield expandDirectories(path.join(baseDir, aPath), files);\n        return children.map((child) => path.join(aPath, child));\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/context.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events = require(\"events\");\nconst _ = require(\"lodash\");\nconst config = require(\"./config\");\nconst plugin_1 = require(\"./plugin\");\n/**\n * Exposes the current state of a WCT run, and emits events/hooks for anyone\n * downstream to listen to.\n *\n * TODO(rictic): break back-compat with plugins by moving hooks entirely away\n *     from callbacks to promises. Easiest way to do this would be to rename\n *     the hook-related methods on this object, so that downstream callers would\n *     break in obvious ways.\n *\n * @param {Object} options Any initially specified options.\n */\nclass Context extends events.EventEmitter {\n    constructor(options) {\n        super();\n        this._hookHandlers = {};\n        options = options || {};\n        /**\n         * The configuration for the current WCT run.\n         *\n         * We guarantee that this object is never replaced (e.g. you are free to\n         * hold a reference to it, and make changes to it).\n         */\n        this.options = config.merge(config.defaults(), config.fromDisk(options.enforceJsonConf, options.root), options);\n    }\n    // Hooks\n    //\n    // In addition to emitting events, a context also exposes \"hooks\" that\n    // interested parties can use to inject behavior.\n    /**\n     * Registers a handler for a particular hook. Hooks are typically configured\n     * to run _before_ a particular behavior.\n     */\n    hook(name, handler) {\n        this._hookHandlers[name] = this._hookHandlers[name] || [];\n        this._hookHandlers[name].unshift(handler);\n    }\n    ;\n    /**\n     * Registers a handler that will run after any handlers registered so far.\n     *\n     * @param {string} name\n     * @param {function(!Object, function(*))} handler\n     */\n    hookLate(name, handler) {\n        this._hookHandlers[name] = this._hookHandlers[name] || [];\n        this._hookHandlers[name].push(handler);\n    }\n    ;\n    emitHook(name, done) {\n        return __awaiter(this, arguments, void 0, function* () {\n            this.emit('log:debug', 'hook:', name);\n            const hooks = (this._hookHandlers[name] || []);\n            let boundHooks;\n            if (arguments.length > 2) {\n                done = arguments[arguments.length - 1];\n                let argsEnd = arguments.length - 1;\n                if (!(done instanceof Function)) {\n                    done = (e) => { };\n                    argsEnd = arguments.length;\n                }\n                const hookArgs = Array.from(arguments).slice(1, argsEnd);\n                boundHooks = hooks.map(function (hook) {\n                    return hook.bind.apply(hook, [null].concat(hookArgs));\n                });\n            }\n            if (!boundHooks) {\n                boundHooks = hooks;\n            }\n            done = done || ((e) => { });\n            // A hook may return a promise or it may call a callback. We want to\n            // treat hooks as though they always return promises, so this converts.\n            const hookToPromise = (hook) => {\n                return new Promise((resolve, reject) => {\n                    const maybePromise = hook((err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                    if (maybePromise) {\n                        maybePromise.then(resolve, reject);\n                    }\n                });\n            };\n            // We execute the handlers _sequentially_. This may be slower, but it gives\n            // us a lighter cognitive load and more obvious logs.\n            try {\n                for (const hook of boundHooks) {\n                    yield hookToPromise(hook);\n                }\n            }\n            catch (err) {\n                // TODO(rictic): stop silently swallowing the error here and just below.\n                //     Looks like we'll need to track down some error being thrown from\n                //     deep inside the express router.\n                try {\n                    done(err);\n                }\n                catch (_) {\n                }\n                throw err;\n            }\n            try {\n                done();\n            }\n            catch (_) {\n            }\n        });\n    }\n    ;\n    /**\n     * @param {function(*, Array<!Plugin>)} done Asynchronously loads the plugins\n     *     requested by `options.plugins`.\n     */\n    plugins() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const plugins = [];\n            for (const name of this.enabledPlugins()) {\n                plugins.push(yield plugin_1.Plugin.get(name));\n            }\n            return plugins;\n        });\n    }\n    /**\n     * @return {!Array<string>} The names of enabled plugins.\n     */\n    enabledPlugins() {\n        // Plugins with falsy configuration or disabled: true are _not_ loaded.\n        const pairs = _.reject(_.pairs(this.options.plugins), (p) => !p[1] || p[1].disabled);\n        return _.map(pairs, (p) => p[0]);\n    }\n    ;\n    /**\n     * @param {string} name\n     * @return {!Object}\n     */\n    pluginOptions(name) {\n        return this.options.plugins[plugin_1.Plugin.shortName(name)];\n    }\n    ;\n}\nContext.Context = Context;\nexports.Context = Context;\nmodule.exports = Context;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/plugin.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nconst path = require(\"path\");\n// Plugin module names can be prefixed by the following:\nconst PREFIXES = [\n    'web-component-tester-',\n    'wct-',\n];\n/**\n * A WCT plugin. This constructor is private. Plugins can be retrieved via\n * `Plugin.get`.\n */\nclass Plugin {\n    constructor(packageName, metadata) {\n        this.packageName = packageName;\n        this.metadata = metadata;\n        this.name = Plugin.shortName(packageName);\n        this.cliConfig = this.metadata['cli-options'] || {};\n    }\n    /**\n     * @param {!Context} context The context that this plugin should be evaluated\n     *     within.\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const plugin = require(this.packageName);\n                plugin(context, context.pluginOptions(this.name), this);\n            }\n            catch (error) {\n                throw `Failed to load plugin \"${this.name}\": ${error}`;\n            }\n        });\n    }\n    ;\n    /**\n     * Retrieves a plugin by shorthand or module name (loading it as necessary).\n     *\n     * @param {string} name\n     */\n    static get(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const shortName = Plugin.shortName(name);\n            if (_loadedPlugins[shortName]) {\n                return _loadedPlugins[shortName];\n            }\n            const names = [shortName].concat(PREFIXES.map((p) => p + shortName));\n            const loaded = _.compact(names.map(_tryLoadPluginPackage));\n            if (loaded.length > 1) {\n                const prettyNames = loaded.map((p) => p.packageName).join(' ');\n                throw `Loaded conflicting WCT plugin packages: ${prettyNames}`;\n            }\n            if (loaded.length < 1) {\n                throw `Could not find WCT plugin named \"${name}\"`;\n            }\n            return loaded[0];\n        });\n    }\n    ;\n    /**\n     * @param {string} name\n     * @return {string} The short form of `name`.\n     */\n    static shortName(name) {\n        for (const prefix of PREFIXES) {\n            if (name.indexOf(prefix) === 0) {\n                return name.substr(prefix.length);\n            }\n        }\n        return name;\n    }\n    ;\n}\n// HACK(rictic): Makes es6 style imports happy, so that we can do, e.g.\n//     import {Plugin} from './plugin';\nPlugin.Plugin = Plugin;\nexports.Plugin = Plugin;\n// Plugin Loading\n// We maintain an identity map of plugins, keyed by short name.\nconst _loadedPlugins = {};\n/**\n * @param {string} packageName Attempts to load a package as a WCT plugin.\n * @return {Plugin}\n */\nfunction _tryLoadPluginPackage(packageName) {\n    let packageInfo;\n    try {\n        packageInfo = require(path.join(packageName, 'package.json'));\n    }\n    catch (error) {\n        if (error.code !== 'MODULE_NOT_FOUND') {\n            console.log(error);\n        }\n        return null;\n    }\n    // Plugins must have a (truthy) wct-plugin field.\n    if (!packageInfo['wct-plugin']) {\n        return null;\n    }\n    // Allow {\"wct-plugin\": true} as a shorthand.\n    const metadata = _.isObject(packageInfo['wct-plugin']) ? packageInfo['wct-plugin'] : {};\n    return new Plugin(packageName, metadata);\n}\nmodule.exports = Plugin;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/test.js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst cleankill = require(\"cleankill\");\nconst clireporter_1 = require(\"./clireporter\");\nconst context_1 = require(\"./context\");\nconst steps = require(\"./steps\");\n/**\n * Runs a suite of web component tests.\n *\n * The returned Context (a kind of EventEmitter) fires various events to allow\n * you to track the progress of the tests:\n *\n * Lifecycle Events:\n *\n * `run-start`\n *   WCT is ready to begin spinning up browsers.\n *\n * `browser-init` {browser} {stats}\n *   WCT is ready to begin spinning up browsers.\n *\n * `browser-start` {browser} {metadata} {stats}\n *   The browser has begun running tests. May fire multiple times (i.e. when\n *   manually refreshing the tests).\n *\n * `sub-suite-start` {browser} {sharedState} {stats}\n *   A suite file has begun running.\n *\n * `test-start` {browser} {test} {stats}\n *   A test has begun.\n *\n * `test-end` {browser} {test} {stats}\n *  A test has ended.\n *\n * `sub-suite-end` {browser} {sharedState} {stats}\n *   A suite file has finished running all of its tests.\n *\n * `browser-end` {browser} {error} {stats}\n *   The browser has completed, and it shutting down.\n *\n * `run-end` {error}\n *   WCT has run all browsers, and is shutting down.\n *\n * Generic Events:\n *\n *  * log:debug\n *  * log:info\n *  * log:warn\n *  * log:error\n *\n * @param {!Config|!Context} options The configuration or an already formed\n *     `Context` object.\n */\nfunction test(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const context = (options instanceof context_1.Context) ? options : new context_1.Context(options);\n        // We assume that any options related to logging are passed in via the initial\n        // `options`.\n        if (context.options.output) {\n            new clireporter_1.CliReporter(context, context.options.output, context.options);\n        }\n        try {\n            yield steps.setupOverrides(context);\n            yield steps.loadPlugins(context);\n            yield steps.configure(context);\n            yield steps.prepare(context);\n            yield steps.runTests(context);\n        }\n        finally {\n            if (!context.options.skipCleanup) {\n                yield new Promise((resolve) => cleankill.close(resolve));\n            }\n        }\n    });\n}\nexports.test = test;\n;\n// HACK\ntest['test'] = test;\nmodule.exports = test;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/steps.js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst http = require(\"http\");\nconst _ = require(\"lodash\");\nconst socketIO = require(\"socket.io\");\nconst browserrunner_1 = require(\"./browserrunner\");\nconst config = require(\"./config\");\nconst webserver_1 = require(\"./webserver\");\n// Steps (& Hooks)\nfunction setupOverrides(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (context.options.registerHooks) {\n            context.options.registerHooks(context);\n        }\n    });\n}\nexports.setupOverrides = setupOverrides;\nfunction loadPlugins(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        context.emit('log:debug', 'step: loadPlugins');\n        const plugins = yield context.plugins();\n        // built in quasi-plugin.\n        webserver_1.webserver(context);\n        // Actual plugins.\n        yield Promise.all(plugins.map(plugin => plugin.execute(context)));\n        return plugins;\n    });\n}\nexports.loadPlugins = loadPlugins;\nfunction configure(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        context.emit('log:debug', 'step: configure');\n        const options = context.options;\n        _.defaults(options, config.defaults());\n        yield config.expand(context);\n        // Note that we trigger the configure hook _after_ filling in the `options`\n        // object.\n        //\n        // If you want to modify options prior to this; do it during plugin init.\n        yield context.emitHook('configure');\n        // Even if the options don't validate; useful debugging info.\n        const cleanOptions = _.omit(options, 'output');\n        context.emit('log:debug', 'configuration:', cleanOptions);\n        yield config.validate(options);\n    });\n}\nexports.configure = configure;\n/**\n * The prepare step is where a lot of the runner's initialization occurs. This\n * is also typically where a plugin will want to spin up any long-running\n * process it requires.\n *\n * Note that some \"plugins\" are also built directly into WCT (webserver).\n */\nfunction prepare(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield context.emitHook('prepare');\n    });\n}\nexports.prepare = prepare;\nfunction runTests(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n        context.emit('log:debug', 'step: runTests');\n        const failed = false;\n        const result = runBrowsers(context);\n        const runners = result.runners;\n        context._testRunners = runners;\n        context._socketIOServer = socketIO(context._httpServer);\n        context._socketIOServer.on('connection', function (socket) {\n            context.emit('log:debug', 'Test client opened sideband socket');\n            socket.on('client-event', function (data) {\n                const runner = runners[data.browserId];\n                if (!runner) {\n                    throw new Error(`Unable to find browser runner for ` +\n                        `browser with id: ${data.browserId}`);\n                }\n                runner.onEvent(data.event, data.data);\n            });\n        });\n        yield result.completionPromise;\n    });\n}\nexports.runTests = runTests;\nfunction cancelTests(context) {\n    if (!context._testRunners) {\n        return;\n    }\n    context._testRunners.forEach(function (tr) {\n        tr.quit();\n    });\n}\nexports.cancelTests = cancelTests;\n// Helpers\nfunction runBrowsers(context) {\n    const options = context.options;\n    const numActiveBrowsers = options.activeBrowsers.length;\n    if (numActiveBrowsers === 0) {\n        throw new Error('No browsers configured to run');\n    }\n    // TODO(nevir): validate browser definitions.\n    // Up the socket limit so that we can maintain more active requests.\n    // TODO(nevir): We should be queueing the browsers above some limit too.\n    http.globalAgent.maxSockets =\n        Math.max(http.globalAgent.maxSockets, numActiveBrowsers * 2);\n    context.emit('run-start', options);\n    const errors = [];\n    const promises = [];\n    const runners = options.activeBrowsers.map(function (browser, id) {\n        // Needed by both `BrowserRunner` and `CliReporter`.\n        browser.id = id;\n        _.defaults(browser, options.browserOptions);\n        const runner = new browserrunner_1.BrowserRunner(context, browser, options);\n        promises.push(runner.donePromise.then(() => {\n            context.emit('log:debug', browser, 'BrowserRunner complete');\n        }, (error) => {\n            context.emit('log:debug', browser, 'BrowserRunner complete');\n            errors.push(error);\n        }));\n        return runner;\n    });\n    return {\n        runners,\n        completionPromise: (function () {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield Promise.all(promises);\n                const error = errors.length > 0 ? _.union(errors).join(', ') : null;\n                context.emit('run-end', error);\n                // TODO(nevir): Better rationalize run-end and hook.\n                yield context.emitHook('cleanup');\n                if (error) {\n                    throw new Error(error);\n                }\n            });\n        }())\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/browserrunner.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk = require(\"chalk\");\nconst cleankill = require(\"cleankill\");\nconst _ = require(\"lodash\");\nconst wd = require(\"wd\");\n// Browser abstraction, responsible for spinning up a browser instance via wd.js\n// and executing runner.html test files passed in options.files\nclass BrowserRunner {\n    constructor(emitter, def, options) {\n        this.emitter = emitter;\n        this.def = def;\n        this.options = options;\n        this.timeout = options.testTimeout;\n        this.emitter = emitter;\n        this.stats = { status: 'initializing' };\n        this.browser = wd.remote(this.def.url);\n        // never retry selenium commands\n        this.browser.configureHttp({ retries: -1 });\n        this.donePromise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        cleankill.onInterrupt((done) => {\n            if (!this.browser) {\n                return done();\n            }\n            this.donePromise.then(() => done(), () => done());\n            this.done('Interrupting');\n        });\n        this.browser.on('command', (method, context) => {\n            emitter.emit('log:debug', this.def, chalk.cyan(method), context);\n        });\n        this.browser.on('http', (method, path, data) => {\n            if (data) {\n                emitter.emit('log:debug', this.def, chalk.magenta(method), chalk.cyan(path), data);\n            }\n            else {\n                emitter.emit('log:debug', this.def, chalk.magenta(method), chalk.cyan(path));\n            }\n        });\n        this.browser.on('connection', (code, message, error) => {\n            emitter.emit('log:warn', this.def, 'Error code ' + code + ':', message, error);\n        });\n        this.emitter.emit('browser-init', this.def, this.stats);\n        // Make sure that we are passing a pristine capabilities object to\n        // webdriver. None of our screwy custom properties!\n        const webdriverCapabilities = _.clone(this.def);\n        delete webdriverCapabilities.id;\n        delete webdriverCapabilities.url;\n        delete webdriverCapabilities.sessionId;\n        // Reusing a session?\n        if (this.def.sessionId) {\n            this.browser.attach(this.def.sessionId, (error) => {\n                this._init(error, this.def.sessionId);\n            });\n        }\n        else {\n            this.browser.init(webdriverCapabilities, this._init.bind(this));\n        }\n    }\n    _init(error, sessionId) {\n        if (!this.browser) {\n            return; // When interrupted.\n        }\n        if (error) {\n            // TODO(nevir): BEGIN TEMPORARY CHECK.\n            // https://github.com/Polymer/web-component-tester/issues/51\n            if (this.def.browserName === 'safari' && error.data) {\n                // debugger;\n                try {\n                    const data = JSON.parse(error.data);\n                    console.log(data.value.message);\n                    if (data.value && data.value.message &&\n                        /Failed to connect to SafariDriver/i.test(data.value.message)) {\n                        error = 'Until Selenium\\'s SafariDriver supports ' +\n                            'Safari 6.2+, 7.1+, & 8.0+, you must\\n' +\n                            'manually install it. Follow the steps at:\\n' +\n                            'https://github.com/SeleniumHQ/selenium/' +\n                            'wiki/SafariDriver#getting-started';\n                    }\n                }\n                catch (error) {\n                    // Show the original error.\n                }\n            }\n            // END TEMPORARY CHECK\n            this.done(error.data || error);\n        }\n        else {\n            this.sessionId = sessionId;\n            this.startTest();\n            this.extendTimeout();\n        }\n    }\n    startTest() {\n        const webserver = this.options.webserver;\n        const host = `http://${webserver.hostname}:${webserver.port}`;\n        const path = this.options.webserver.webRunnerPath;\n        const extra = (path.indexOf('?') === -1 ? '?' : '&') +\n            `cli_browser_id=${this.def.id}`;\n        this.browser.get(host + path + extra, (error) => {\n            if (error) {\n                this.done(error.data || error);\n            }\n            else {\n                this.extendTimeout();\n            }\n        });\n    }\n    onEvent(event, data) {\n        this.extendTimeout();\n        if (event === 'browser-start') {\n            // Always assign, to handle re-runs (no browser-init).\n            this.stats = {\n                status: 'running',\n                passing: 0,\n                pending: 0,\n                failing: 0,\n            };\n        }\n        else if (event === 'test-end') {\n            this.stats[data.state] = this.stats[data.state] + 1;\n        }\n        if (event === 'browser-end' || event === 'browser-fail') {\n            this.done(data);\n        }\n        else {\n            this.emitter.emit(event, this.def, data, this.stats, this.browser);\n        }\n    }\n    done(error) {\n        // No quitting for you!\n        if (this.options.persistent) {\n            return;\n        }\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n        // Don't double-quit.\n        if (!this.browser) {\n            return;\n        }\n        const browser = this.browser;\n        this.browser = null;\n        this.stats.status = error ? 'error' : 'complete';\n        if (!error && this.stats.failing > 0) {\n            error = this.stats.failing + ' failed tests';\n        }\n        this.emitter.emit('browser-end', this.def, error, this.stats, this.sessionId, browser);\n        // Nothing to quit.\n        if (!this.sessionId) {\n            error ? this._reject(error) : this._resolve();\n        }\n        browser.quit((quitError) => {\n            if (quitError) {\n                this.emitter.emit('log:warn', this.def, 'Failed to quit:', quitError.data || quitError);\n            }\n            if (error) {\n                this._reject(error);\n            }\n            else {\n                this._resolve();\n            }\n        });\n    }\n    extendTimeout() {\n        if (this.options.persistent) {\n            return;\n        }\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n        this.timeoutId = setTimeout(() => {\n            this.done('Timed out');\n        }, this.timeout);\n    }\n    quit() {\n        this.done('quit was called');\n    }\n}\n// HACK\nBrowserRunner.BrowserRunner = BrowserRunner;\nexports.BrowserRunner = BrowserRunner;\nmodule.exports = BrowserRunner;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/webserver.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk = require(\"chalk\");\nconst cleankill = require(\"cleankill\");\nconst express = require(\"express\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst _ = require(\"lodash\");\nconst path = require(\"path\");\nconst send = require(\"send\");\nconst serveWaterfall = require(\"serve-waterfall\");\nconst serverDestroy = require(\"server-destroy\");\nconst httpbin = require(\"./httpbin\");\nconst port_scanner_1 = require(\"./port-scanner\");\n// Template for generated indexes.\nconst INDEX_TEMPLATE = _.template(fs.readFileSync(path.resolve(__dirname, '../data/index.html'), { encoding: 'utf-8' }));\n// We prefer serving local assets over bower assets.\nconst PACKAGE_ROOT = path.resolve(__dirname, '..');\nconst SERVE_STATIC = {\n    // Keys are regexps.\n    '^(.*/web-component-tester|)/browser\\\\.js$': path.join(PACKAGE_ROOT, 'browser.js'),\n    '^(.*/web-component-tester|)/browser\\\\.js\\\\.map$': path.join(PACKAGE_ROOT, 'browser.js.map'),\n    '^(.*/web-component-tester|)/data/a11ySuite\\\\.js$': path.join(PACKAGE_ROOT, 'data', 'a11ySuite.js'),\n};\nconst DEFAULT_HEADERS = {\n    'Cache-Control': 'no-cache, no-store, must-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': 0,\n};\n// Sauce Labs compatible ports\n// taken from\n// https://docs.saucelabs.com/reference/sauce-connect/#can-i-access-applications-on-localhost-\n// - 80, 443, 888: these ports must have root access\n// - 5555, 8080: not forwarded on Android\nconst SAUCE_PORTS = [\n    2000, 2001, 2020, 2109, 2222, 2310, 3000, 3001, 3030, 3210, 3333, 4000,\n    4001, 4040, 4321, 4502, 4503, 4567, 5000, 5001, 5050, 5432, 6000, 6001,\n    6060, 6666, 6543, 7000, 7070, 7774, 7777, 8000, 8001, 8003, 8031, 8081,\n    8765, 8777, 8888, 9000, 9001, 9080, 9090, 9876, 9877, 9999, 49221, 55001\n];\n/**\n * The webserver module is a quasi-plugin. This ensures that it is hooked in a\n * sane way (for other plugins), and just follows the same flow.\n *\n * It provides a static HTTP server for serving the desired tests and WCT's\n * `browser.js`/`environment.js`.\n */\nfunction webserver(wct) {\n    const options = wct.options;\n    wct.hook('configure', function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            // For now, you should treat all these options as an implementation detail\n            // of WCT. They may be opened up for public configuration, but we need to\n            // spend some time rationalizing interactions with external webservers.\n            options.webserver = _.merge(options.webserver, {\n                // The URL path that each test run should target.\n                webRunnerPath: undefined,\n                // If present, HTML content that should be served at `webRunner`.\n                webRunnerContent: undefined,\n                // Map of route expressions (regular expressions) to local file paths that\n                // should be served by the webserver.\n                staticContent: SERVE_STATIC,\n            });\n            if (options.verbose) {\n                options.clientOptions.verbose = true;\n            }\n            // Prefix our web runner URL with the base path.\n            let urlPrefix = options.webserver.urlPrefix;\n            urlPrefix = urlPrefix.replace('<basename>', path.basename(options.root));\n            options.webserver.webRunnerPath = urlPrefix + '/generated-index.html';\n            // Hacky workaround for Firefox + Windows issue where FF screws up pathing.\n            // Bug: https://github.com/Polymer/web-component-tester/issues/194\n            options.suites = options.suites.map((cv) => cv.replace(/\\\\/g, '/'));\n            options.webserver.webRunnerContent = INDEX_TEMPLATE(options);\n        });\n    });\n    wct.hook('prepare', function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wsOptions = options.webserver;\n            const port = yield getPort();\n            // `port` (and `webRunnerPath`) is read down the line by `BrowserRunner`.\n            wsOptions.port = port;\n            const app = express();\n            const server = http.createServer(app);\n            // `runTests` needs a reference to this (for the socket.io endpoint).\n            wct._httpServer = server;\n            // Debugging information for each request.\n            app.use(function (request, response, next) {\n                const msg = request.url + ' (' + request.header('referer') + ')';\n                wct.emit('log:debug', chalk.magenta(request.method), msg);\n                next();\n            });\n            // Mapped static content (overriding files served at the root).\n            _.each(wsOptions.staticContent, function (file, url) {\n                app.get(new RegExp(url), function (request, response) {\n                    response.set(DEFAULT_HEADERS);\n                    send(request, file).pipe(response);\n                });\n            });\n            // The generated web runner, if present.\n            if (wsOptions.webRunnerContent) {\n                app.get(wsOptions.webRunnerPath, function (request, response) {\n                    response.set(DEFAULT_HEADERS);\n                    response.send(wsOptions.webRunnerContent);\n                });\n            }\n            // At this point, we allow other plugins to hook and configure the\n            // webserver as they please.\n            yield wct.emitHook('prepare:webserver', app);\n            // Serve up all the static assets.\n            app.use(serveWaterfall(wsOptions.pathMappings, {\n                root: options.root,\n                headers: DEFAULT_HEADERS,\n                log: wct.emit.bind(wct, 'log:debug'),\n            }));\n            app.use('/httpbin', httpbin.httpbin);\n            app.get('/favicon.ico', function (request, response) {\n                response.end();\n            });\n            app.use(function (request, response, next) {\n                wct.emit('log:warn', '404', chalk.magenta(request.method), request.url);\n                next();\n            });\n            server.listen(port);\n            server.port = port;\n            serverDestroy(server);\n            cleankill.onInterrupt(function (done) {\n                // close the socket IO server directly if it is spun up\n                const io = wct._socketIOServer;\n                if (io) {\n                    // we will close the underlying server ourselves\n                    io.httpServer = null;\n                    io.close();\n                }\n                server.destroy();\n                server.on('close', done);\n            });\n            wct.emit('log:info', 'Web server running on port', chalk.yellow(port.toString()), 'and serving from', chalk.magenta(options.root));\n        });\n    });\n    function getPort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (options.webserver.port) {\n                return options.webserver.port;\n            }\n            else {\n                return yield port_scanner_1.findPort(SAUCE_PORTS);\n            }\n        });\n    }\n}\nexports.webserver = webserver;\n;\n// HACK(rictic): remove this ES6-compat hack and export webserver itself\nwebserver['webserver'] = webserver;\nmodule.exports = webserver;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/httpbin.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bodyParser = require(\"body-parser\");\nconst cleankill = require(\"cleankill\");\nconst express = require(\"express\");\nconst http = require(\"http\");\nconst multer = require(\"multer\");\nconst serverDestroy = require(\"server-destroy\");\nconst port_scanner_1 = require(\"./port-scanner\");\nvar express_1 = require(\"express\");\nexports.Router = express_1.Router;\nexports.httpbin = express.Router();\nfunction capWords(s) {\n    return s.split('-')\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('-');\n}\nfunction formatRequest(req) {\n    const headers = {};\n    for (const key in req.headers) {\n        headers[capWords(key)] = req.headers[key];\n    }\n    const formatted = {\n        headers: headers,\n        url: req.originalUrl,\n        data: req.body,\n        files: req.files,\n        form: {},\n        json: {},\n    };\n    const contentType = (headers['Content-Type'] || '').toLowerCase().split(';')[0];\n    const field = {\n        'application/json': 'json',\n        'application/x-www-form-urlencoded': 'form',\n        'multipart/form-data': 'form'\n    }[contentType];\n    if (field) {\n        formatted[field] = req.body;\n    }\n    return formatted;\n}\nexports.httpbin.use(bodyParser.urlencoded({ extended: false }));\nexports.httpbin.use(bodyParser.json());\nconst storage = multer.memoryStorage();\nconst upload = multer({ storage: storage });\nexports.httpbin.use(upload.any());\nexports.httpbin.use(bodyParser.text());\nexports.httpbin.use(bodyParser.text({ type: 'html' }));\nexports.httpbin.use(bodyParser.text({ type: 'xml' }));\nexports.httpbin.get('/delay/:seconds', function (req, res) {\n    setTimeout(function () {\n        res.json(formatRequest(req));\n    }, (req.params.seconds || 0) * 1000);\n});\nexports.httpbin.post('/post', function (req, res) {\n    res.json(formatRequest(req));\n});\n// Running this script directly with `node httpbin.js` will start up a server\n// that just serves out /httpbin/...\n// Useful for debugging only the httpbin functionality without the rest of\n// wct.\nfunction main() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const app = express();\n        const server = http.createServer(app);\n        app.use('/httpbin', exports.httpbin);\n        const port = yield port_scanner_1.findPort([7777, 7000, 8000, 8080, 8888]);\n        server.listen(port);\n        server.port = port;\n        serverDestroy(server);\n        cleankill.onInterrupt((done) => {\n            server.destroy();\n            server.on('close', done);\n        });\n        console.log('Server running at http://localhost:' + port + '/httpbin/');\n    });\n}\nif (require.main === module) {\n    main().catch((err) => {\n        console.error(err);\n        process.exit(1);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/port-scanner.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net = require(\"net\");\nfunction checkPort(port) {\n    return new Promise(function (resolve) {\n        const server = net.createServer();\n        let hasPort = false;\n        // if server is listening, we have the port!\n        server.on('listening', function (err) {\n            hasPort = true;\n            server.close();\n        });\n        // callback on server close to free up the port before report it can be used\n        server.on('close', function (err) {\n            resolve(hasPort);\n        });\n        // our port is busy, ignore it\n        server.on('error', function (err) {\n            // docs say the server should close, this doesn't seem to be the case :(\n            server.close();\n        });\n        server.listen(port);\n    });\n}\nfunction detectSeries(values, promiseGetter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const value of values) {\n            if (yield promiseGetter(value)) {\n                return value;\n            }\n        }\n        throw new Error('Couldn\\'t find a good value in detectSeries');\n    });\n}\nfunction findPort(ports) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            return yield detectSeries(ports, checkPort);\n        }\n        catch (error) {\n            throw new Error('no port found!');\n        }\n    });\n}\nexports.findPort = findPort;\n;\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/runner/gulp.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk = require(\"chalk\");\nconst test_1 = require(\"./test\");\nfunction init(gulp, dependencies) {\n    if (!dependencies) {\n        dependencies = [];\n    }\n    // TODO(nevir): Migrate fully to wct:local/etc.\n    gulp.task('test', ['wct:local']);\n    gulp.task('test:local', ['wct:local']);\n    gulp.task('test:remote', ['wct:sauce']);\n    gulp.task('wct', ['wct:local']);\n    gulp.task('wct:local', dependencies, () => {\n        return test_1.test({ plugins: { local: {}, sauce: false } }).catch(cleanError);\n    });\n    gulp.task('wct:sauce', dependencies, () => {\n        return test_1.test({ plugins: { local: false, sauce: {} } }).catch(cleanError);\n    });\n}\nexports.init = init;\n// Utility\nfunction cleanError(error) {\n    // Pretty error for gulp.\n    error = new Error(chalk.red(error.message || error));\n    error.showStack = false;\n    throw error;\n}\n","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/browser.js":"/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function () {\n'use strict';\n\n/**\n * @param {function()} callback A function to call when the active web component\n *     frameworks have loaded.\n */\nfunction whenFrameworksReady(callback) {\n  debug('whenFrameworksReady');\n  var done = function() {\n    debug('whenFrameworksReady done');\n    callback();\n  };\n\n  function whenWebComponentsReady() {\n    debug('WebComponentsReady?');\n    if (window.WebComponents && WebComponents.whenReady) {\n      WebComponents.whenReady(function() {\n        debug('WebComponents Ready');\n        done();\n      });\n    } else {\n      var after = function after() {\n        window.removeEventListener('WebComponentsReady', after);\n        debug('WebComponentsReady');\n        done();\n      };\n      window.addEventListener('WebComponentsReady', after);\n    }\n  }\n\n  function importsReady() {\n    // handle Polymer 0.5 readiness\n    debug('Polymer ready?');\n    if (window.Polymer && Polymer.whenReady) {\n      Polymer.whenReady(function() {\n        debug('Polymer ready');\n        done();\n      });\n    } else {\n      whenWebComponentsReady();\n    }\n  }\n\n  // All our supported framework configurations depend on imports.\n  if (!window.HTMLImports) {\n    done();\n  } else if (HTMLImports.ready) {\n    debug('HTMLImports ready');\n    importsReady();\n  } else if (HTMLImports.whenReady) {\n    HTMLImports.whenReady(function() {\n      debug('HTMLImports.whenReady ready');\n      importsReady();\n    });\n  } else {\n    whenWebComponentsReady();\n  }\n}\n\n/**\n * @param {number} count\n * @param {string} kind\n * @return {string} '<count> <kind> tests' or '<count> <kind> test'.\n */\nfunction pluralizedStat(count, kind) {\n  if (count === 1) {\n    return count + ' ' + kind + ' test';\n  } else {\n    return count + ' ' + kind + ' tests';\n  }\n}\n\n/**\n * @param {string} path The URI of the script to load.\n * @param {function} done\n */\nfunction loadScript(path, done) {\n  var script = document.createElement('script');\n  script.src = path;\n  if (done) {\n    script.onload = done.bind(null, null);\n    script.onerror = done.bind(null, 'Failed to load script ' + script.src);\n  }\n  document.head.appendChild(script);\n}\n\n/**\n * @param {string} path The URI of the stylesheet to load.\n * @param {function} done\n */\nfunction loadStyle(path, done) {\n  var link = document.createElement('link');\n  link.rel  = 'stylesheet';\n  link.href = path;\n  if (done) {\n    link.onload = done.bind(null, null);\n    link.onerror = done.bind(null, 'Failed to load stylesheet ' + link.href);\n  }\n  document.head.appendChild(link);\n}\n\n/**\n * @param {...*} var_args Logs values to the console when the `debug`\n *     configuration option is true.\n */\nfunction debug(var_args) {\n  if (!get('verbose')) return;\n  var args = [window.location.pathname];\n  args.push.apply(args, arguments);\n  (console.debug || console.log).apply(console, args);\n}\n\n// URL Processing\n\n/**\n * @param {string} url\n * @return {{base: string, params: string}}\n */\nfunction parseUrl(url) {\n  var parts = url.match(/^(.*?)(?:\\?(.*))?$/);\n  return {\n    base:   parts[1],\n    params: getParams(parts[2] || ''),\n  };\n}\n\n/**\n * Expands a URL that may or may not be relative to `base`.\n *\n * @param {string} url\n * @param {string} base\n * @return {string}\n */\nfunction expandUrl(url, base) {\n  if (!base) return url;\n  if (url.match(/^(\\/|https?:\\/\\/)/)) return url;\n  if (base.substr(base.length - 1) !== '/') {\n    base = base + '/';\n  }\n  return base + url;\n}\n\n/**\n * @param {string=} opt_query A query string to parse.\n * @return {!Object<string, !Array<string>>} All params on the URL's query.\n */\nfunction getParams(opt_query) {\n  var query = typeof opt_query === 'string' ? opt_query : window.location.search;\n  if (query.substring(0, 1) === '?') {\n    query = query.substring(1);\n  }\n  // python's SimpleHTTPServer tacks a `/` on the end of query strings :(\n  if (query.slice(-1) === '/') {\n    query = query.substring(0, query.length - 1);\n  }\n  if (query === '') return {};\n\n  var result = {};\n  query.split('&').forEach(function(part) {\n    var pair = part.split('=');\n    if (pair.length !== 2) {\n      console.warn('Invalid URL query part:', part);\n      return;\n    }\n    var key   = decodeURIComponent(pair[0]);\n    var value = decodeURIComponent(pair[1]);\n\n    if (!result[key]) {\n      result[key] = [];\n    }\n    result[key].push(value);\n  });\n\n  return result;\n}\n\n/**\n * Merges params from `source` into `target` (mutating `target`).\n *\n * @param {!Object<string, !Array<string>>} target\n * @param {!Object<string, !Array<string>>} source\n */\nfunction mergeParams(target, source) {\n  Object.keys(source).forEach(function(key) {\n    if (!(key in target)) {\n      target[key] = [];\n    }\n    target[key] = target[key].concat(source[key]);\n  });\n}\n\n/**\n * @param {string} param The param to return a value for.\n * @return {?string} The first value for `param`, if found.\n */\nfunction getParam(param) {\n  var params = getParams();\n  return params[param] ? params[param][0] : null;\n}\n\n/**\n * @param {!Object<string, !Array<string>>} params\n * @return {string} `params` encoded as a URI query.\n */\nfunction paramsToQuery(params) {\n  var pairs = [];\n  Object.keys(params).forEach(function(key) {\n    params[key].forEach(function(value) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n    });\n  });\n  return (pairs.length > 0) ? ('?' + pairs.join('&')) : '';\n}\n\n/**\n * @param {!Location|string} location\n * @return {string}\n */\nfunction basePath(location) {\n  return (location.pathname || location).match(/^.*\\//)[0];\n}\n\n/**\n * @param {!Location|string} location\n * @param {string} basePath\n * @return {string}\n */\nfunction relativeLocation(location, basePath) {\n  var path = location.pathname || location;\n  if (path.indexOf(basePath) === 0) {\n    path = path.substring(basePath.length);\n  }\n  return path;\n}\n\n/**\n * @param {!Location|string} location\n * @return {string}\n */\nfunction cleanLocation(location) {\n  var path = location.pathname || location;\n  if (path.slice(-11) === '/index.html') {\n    path = path.slice(0, path.length - 10);\n  }\n  return path;\n}\n\n/**\n * Like `async.parallelLimit`, but our own so that we don't force a dependency\n * on downstream code.\n *\n * @param {!Array<function(function(*))>} runners Runners that call their given\n *     Node-style callback when done.\n * @param {number|function(*)} limit Maximum number of concurrent runners.\n *     (optional).\n * @param {?function(*)} done Callback that should be triggered once all runners\n *     have completed, or encountered an error.\n */\nfunction parallel(runners, limit, done) {\n  if (typeof limit !== 'number') {\n    done  = limit;\n    limit = 0;\n  }\n  if (!runners.length) return done();\n\n  var called    = false;\n  var total     = runners.length;\n  var numActive = 0;\n  var numDone   = 0;\n\n  function runnerDone(error) {\n    if (called) return;\n    numDone = numDone + 1;\n    numActive = numActive - 1;\n\n    if (error || numDone >= total) {\n      called = true;\n      done(error);\n    } else {\n      runOne();\n    }\n  }\n\n  function runOne() {\n    if (limit && numActive >= limit) return;\n    if (!runners.length) return;\n    numActive = numActive + 1;\n    runners.shift()(runnerDone);\n  }\n  runners.forEach(runOne);\n}\n\n/**\n * Finds the directory that a loaded script is hosted on.\n *\n * @param {string} filename\n * @return {string?}\n */\nfunction scriptPrefix(filename) {\n  var scripts = document.querySelectorAll('script[src*=\"' + filename + '\"]');\n  if (scripts.length !== 1) return null;\n  var script = scripts[0].src;\n  return script.substring(0, script.indexOf(filename));\n}\n\n\nvar util = Object.freeze({\n  whenFrameworksReady: whenFrameworksReady,\n  pluralizedStat: pluralizedStat,\n  loadScript: loadScript,\n  loadStyle: loadStyle,\n  debug: debug,\n  parseUrl: parseUrl,\n  expandUrl: expandUrl,\n  getParams: getParams,\n  mergeParams: mergeParams,\n  getParam: getParam,\n  paramsToQuery: paramsToQuery,\n  basePath: basePath,\n  relativeLocation: relativeLocation,\n  cleanLocation: cleanLocation,\n  parallel: parallel,\n  scriptPrefix: scriptPrefix\n});\n\n// TODO(thedeeno): Consider renaming subsuite. IIRC, childRunner is entirely\n// distinct from mocha suite, which tripped me up badly when trying to add\n// plugin support. Perhaps something like 'batch', or 'bundle'. Something that\n// has no mocha correlate. This may also eliminate the need for root/non-root\n// suite distinctions.\n\n/**\n * A Mocha suite (or suites) run within a child iframe, but reported as if they\n * are part of the current context.\n */\nfunction ChildRunner(url, parentScope) {\n  var urlBits = parseUrl(url);\n  mergeParams(\n      urlBits.params, getParams(parentScope.location.search));\n  delete urlBits.params.cli_browser_id;\n\n  this.url         = urlBits.base + paramsToQuery(urlBits.params);\n  this.parentScope = parentScope;\n\n  this.state = 'initializing';\n}\n\n// ChildRunners get a pretty generous load timeout by default.\nChildRunner.loadTimeout = 60000;\n\n// We can't maintain properties on iframe elements in Firefox/Safari/???, so we\n// track childRunners by URL.\nChildRunner._byUrl = {};\n\n/**\n * @return {ChildRunner} The `ChildRunner` that was registered for this window.\n */\nChildRunner.current = function() {\n  return ChildRunner.get(window);\n};\n\n/**\n * @param {!Window} target A window to find the ChildRunner of.\n * @param {boolean} traversal Whether this is a traversal from a child window.\n * @return {ChildRunner} The `ChildRunner` that was registered for `target`.\n */\nChildRunner.get = function(target, traversal) {\n  var childRunner = ChildRunner._byUrl[target.location.href];\n  if (childRunner) return childRunner;\n  if (window.parent === window) {  // Top window.\n    if (traversal) {\n      console.warn('Subsuite loaded but was never registered. This most likely is due to wonky history behavior. Reloading...');\n      window.location.reload();\n    }\n    return null;\n  }\n  // Otherwise, traverse.\n  return window.parent.WCT._ChildRunner.get(target, true);\n};\n\n/**\n * Loads and runs the subsuite.\n *\n * @param {function} done Node-style callback.\n */\nChildRunner.prototype.run = function(done) {\n  debug('ChildRunner#run', this.url);\n  this.state = 'loading';\n  this.onRunComplete = done;\n\n  this.iframe = document.createElement('iframe');\n  this.iframe.src = this.url;\n  this.iframe.classList.add('subsuite');\n\n  var container = document.getElementById('subsuites');\n  if (!container) {\n    container = document.createElement('div');\n    container.id = 'subsuites';\n    document.body.appendChild(container);\n  }\n  container.appendChild(this.iframe);\n\n  // let the iframe expand the URL for us.\n  this.url = this.iframe.src;\n  ChildRunner._byUrl[this.url] = this;\n\n  this.timeoutId = setTimeout(\n      this.loaded.bind(this, new Error('Timed out loading ' + this.url)), ChildRunner.loadTimeout);\n\n  this.iframe.addEventListener('error',\n      this.loaded.bind(this, new Error('Failed to load document ' + this.url)));\n\n  this.iframe.contentWindow.addEventListener('DOMContentLoaded', this.loaded.bind(this, null));\n};\n\n/**\n * Called when the sub suite's iframe has loaded (or errored during load).\n *\n * @param {*} error The error that occured, if any.\n */\nChildRunner.prototype.loaded = function(error) {\n  debug('ChildRunner#loaded', this.url, error);\n\n  // Not all targets have WCT loaded (compatiblity mode)\n  if (this.iframe.contentWindow.WCT) {\n    this.share = this.iframe.contentWindow.WCT.share;\n  }\n\n  if (error) {\n    this.signalRunComplete(error);\n    this.done();\n  }\n};\n\n/**\n * Called in mocha/run.js when all dependencies have loaded, and the child is\n * ready to start running tests\n *\n * @param {*} error The error that occured, if any.\n */\nChildRunner.prototype.ready = function(error) {\n  debug('ChildRunner#ready', this.url, error);\n  if (this.timeoutId) {\n    clearTimeout(this.timeoutId);\n  }\n  if (error) {\n    this.signalRunComplete(error);\n    this.done();\n  }\n};\n\n/** Called when the sub suite's tests are complete, so that it can clean up. */\nChildRunner.prototype.done = function done() {\n  debug('ChildRunner#done', this.url, arguments);\n\n  // make sure to clear that timeout\n  this.ready();\n  this.signalRunComplete();\n\n  if (!this.iframe) return;\n  // Be safe and avoid potential browser crashes when logic attempts to interact\n  // with the removed iframe.\n  setTimeout(function() {\n    this.iframe.parentNode.removeChild(this.iframe);\n    this.iframe = null;\n  }.bind(this), 1);\n};\n\nChildRunner.prototype.signalRunComplete = function signalRunComplete(error) {\n  if (!this.onRunComplete) return;\n  this.state = 'complete';\n  this.onRunComplete(error);\n  this.onRunComplete = null;\n};\n\n/**\n * The global configuration state for WCT's browser client.\n */\nvar _config = {\n  /**\n   * `.js` scripts to be loaded (synchronously) before WCT starts in earnest.\n   *\n   * Paths are relative to `scriptPrefix`.\n   */\n  environmentScripts: [\n    'stacky/browser.js',\n    'async/lib/async.js',\n    'lodash/lodash.js',\n    'mocha/mocha.js',\n    'chai/chai.js',\n    'sinonjs/sinon.js',\n    'sinon-chai/lib/sinon-chai.js',\n    'accessibility-developer-tools/dist/js/axs_testing.js'\n  ],\n\n  environmentImports: [\n    'test-fixture/test-fixture.html'\n  ],\n\n  /** Absolute root for client scripts. Detected in `setup()` if not set. */\n  root: null,\n\n  /** By default, we wait for any web component frameworks to load. */\n  waitForFrameworks: true,\n\n  /** Alternate callback for waiting for tests.\n   * `this` for the callback will be the window currently running tests.\n   */\n  waitFor: null,\n\n  /** How many `.html` suites that can be concurrently loaded & run. */\n  numConcurrentSuites: 1,\n\n  /** Whether `console.error` should be treated as a test failure. */\n  trackConsoleError: true,\n\n  /** Configuration passed to mocha.setup. */\n  mochaOptions: {\n    timeout: 10 * 1000\n  },\n\n  /** Whether WCT should emit (extremely verbose) debugging log messages. */\n  verbose: false,\n};\n\n/**\n * Merges initial `options` into WCT's global configuration.\n *\n * @param {Object} options The options to merge. See `browser/config.js` for a\n *     reference.\n */\nfunction setup(options) {\n  var childRunner = ChildRunner.current();\n  if (childRunner) {\n    _deepMerge(_config, childRunner.parentScope.WCT._config);\n    // But do not force the mocha UI\n    delete _config.mochaOptions.ui;\n  }\n\n  if (options && typeof options === 'object') {\n    _deepMerge(_config, options);\n  }\n\n  if (!_config.root) {\n    // Sibling dependencies.\n    var root = scriptPrefix('browser.js');\n    _config.root = basePath(root.substr(0, root.length - 1));\n    if (!_config.root) {\n      throw new Error('Unable to detect root URL for WCT sources. Please set WCT.root before including browser.js');\n    }\n  }\n}\n\n/**\n * Retrieves a configuration value.\n *\n * @param {string} key\n * @return {*}\n */\nfunction get(key) {\n  return _config[key];\n}\n\n// Internal\n\nfunction _deepMerge(target, source) {\n  Object.keys(source).forEach(function(key) {\n    if (target[key] !== null && typeof target[key] === 'object' && !Array.isArray(target[key])) {\n      _deepMerge(target[key], source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  });\n}\n\nvar htmlSuites$1 = [];\nvar jsSuites$1   = [];\n\n// We process grep ourselves to avoid loading suites that will be filtered.\nvar GREP = getParam('grep');\n// work around mocha bug (https://github.com/mochajs/mocha/issues/2070)\nif (GREP) {\n  GREP = GREP.replace(/\\\\\\./g, '.');\n}\n\n/**\n * Loads suites of tests, supporting both `.js` and `.html` files.\n *\n * @param {!Array.<string>} files The files to load.\n */\nfunction loadSuites(files) {\n  files.forEach(function(file) {\n    if (/\\.js(\\?.*)?$/.test(file)) {\n      jsSuites$1.push(file);\n    } else if (/\\.html(\\?.*)?$/.test(file)) {\n      htmlSuites$1.push(file);\n    } else {\n      throw new Error('Unknown resource type: ' + file);\n    }\n  });\n}\n\n/**\n * @return {!Array.<string>} The child suites that should be loaded, ignoring\n *     those that would not match `GREP`.\n */\nfunction activeChildSuites() {\n  var subsuites = htmlSuites$1;\n  if (GREP) {\n    var cleanSubsuites = [];\n    for (var i = 0, subsuite; subsuite = subsuites[i]; i++) {\n      if (GREP.indexOf(cleanLocation(subsuite)) !== -1) {\n        cleanSubsuites.push(subsuite);\n      }\n    }\n    subsuites = cleanSubsuites;\n  }\n  return subsuites;\n}\n\n/**\n * Loads all `.js` sources requested by the current suite.\n *\n * @param {!MultiReporter} reporter\n * @param {function} done\n */\nfunction loadJsSuites(reporter, done) {\n  debug('loadJsSuites', jsSuites$1);\n\n  var loaders = jsSuites$1.map(function(file) {\n    // We only support `.js` dependencies for now.\n    return loadScript.bind(util, file);\n  });\n\n  parallel(loaders, done);\n}\n\n/**\n * @param {!MultiReporter} reporter\n * @param {!Array.<string>} childSuites\n * @param {function} done\n */\nfunction runSuites(reporter, childSuites, done) {\n  debug('runSuites');\n\n  var suiteRunners = [\n    // Run the local tests (if any) first, not stopping on error;\n    _runMocha.bind(null, reporter),\n  ];\n\n  // As well as any sub suites. Again, don't stop on error.\n  childSuites.forEach(function(file) {\n    suiteRunners.push(function(next) {\n      var childRunner = new ChildRunner(file, window);\n      reporter.emit('childRunner start', childRunner);\n      childRunner.run(function(error) {\n        reporter.emit('childRunner end', childRunner);\n        if (error) reporter.emitOutOfBandTest(file, error);\n        next();\n      });\n    });\n  });\n\n  parallel(suiteRunners, get('numConcurrentSuites'), function(error) {\n    reporter.done();\n    done(error);\n  });\n}\n\n/**\n * Kicks off a mocha run, waiting for frameworks to load if necessary.\n *\n * @param {!MultiReporter} reporter Where to send Mocha's events.\n * @param {function} done A callback fired, _no error is passed_.\n */\nfunction _runMocha(reporter, done, waited) {\n  if (get('waitForFrameworks') && !waited) {\n    var waitFor = (get('waitFor') || whenFrameworksReady).bind(window);\n    waitFor(_runMocha.bind(null, reporter, done, true));\n    return;\n  }\n  debug('_runMocha');\n  var mocha = window.mocha;\n  var Mocha = window.Mocha;\n\n  mocha.reporter(reporter.childReporter(window.location));\n  mocha.suite.title = reporter.suiteTitle(window.location);\n  mocha.grep(GREP);\n\n  // We can't use `mocha.run` because it bashes over grep, invert, and friends.\n  // See https://github.com/visionmedia/mocha/blob/master/support/tail.js#L137\n  var runner = Mocha.prototype.run.call(mocha, function(error) {\n    if (document.getElementById('mocha')) {\n      Mocha.utils.highlightTags('code');\n    }\n    done();  // We ignore the Mocha failure count.\n  });\n\n  // Mocha's default `onerror` handling strips the stack (to support really old\n  // browsers). We upgrade this to get better stacks for async errors.\n  //\n  // TODO(nevir): Can we expand support to other browsers?\n  if (navigator.userAgent.match(/chrome/i)) {\n    window.onerror = null;\n    window.addEventListener('error', function(event) {\n      if (!event.error) return;\n      if (event.error.ignore) return;\n      runner.uncaught(event.error);\n    });\n  }\n}\n\n// We capture console events when running tests; so make sure we have a\n// reference to the original one.\nvar console$1 = window.console;\n\nvar FONT = ';font: normal 13px \"Roboto\", \"Helvetica Neue\", \"Helvetica\", sans-serif;';\nvar STYLES = {\n  plain:   FONT,\n  suite:   'color: #5c6bc0' + FONT,\n  test:    FONT,\n  passing: 'color: #259b24' + FONT,\n  pending: 'color: #e65100' + FONT,\n  failing: 'color: #c41411' + FONT,\n  stack:   'color: #c41411',\n  results: FONT + 'font-size: 16px',\n};\n\n// I don't think we can feature detect this one...\nvar userAgent = navigator.userAgent.toLowerCase();\nvar CAN_STYLE_LOG   = userAgent.match('firefox') || userAgent.match('webkit');\nvar CAN_STYLE_GROUP = userAgent.match('webkit');\n// Track the indent for faked `console.group`\nvar logIndent = '';\n\nfunction log(text, style) {\n  text = text.split('\\n').map(function(l) { return logIndent + l; }).join('\\n');\n  if (CAN_STYLE_LOG) {\n    console$1.log('%c' + text, STYLES[style] || STYLES.plain);\n  } else {\n    console$1.log(text);\n  }\n}\n\nfunction logGroup(text, style) {\n  if (CAN_STYLE_GROUP) {\n    console$1.group('%c' + text, STYLES[style] || STYLES.plain);\n  } else if (console$1.group) {\n    console$1.group(text);\n  } else {\n    logIndent = logIndent + '  ';\n    log(text, style);\n  }\n}\n\nfunction logGroupEnd() {\n  if (console$1.groupEnd) {\n    console$1.groupEnd();\n  } else {\n    logIndent = logIndent.substr(0, logIndent.length - 2);\n  }\n}\n\nfunction logException(error) {\n  log(error.stack || error.message || error, 'stack');\n}\n\n/**\n * A Mocha reporter that logs results out to the web `console`.\n *\n * @param {!Mocha.Runner} runner The runner that is being reported on.\n */\nfunction Console(runner) {\n  Mocha.reporters.Base.call(this, runner);\n\n  runner.on('suite', function(suite) {\n    if (suite.root) return;\n    logGroup(suite.title, 'suite');\n  }.bind(this));\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) return;\n    logGroupEnd();\n  }.bind(this));\n\n  runner.on('test', function(test) {\n    logGroup(test.title, 'test');\n  }.bind(this));\n\n  runner.on('pending', function(test) {\n    logGroup(test.title, 'pending');\n  }.bind(this));\n\n  runner.on('fail', function(test, error) {\n    logException(error);\n  }.bind(this));\n\n  runner.on('test end', function(test) {\n    logGroupEnd();\n  }.bind(this));\n\n  runner.on('end', this.logSummary.bind(this));\n}\n\n/** Prints out a final summary of test results. */\nConsole.prototype.logSummary = function logSummary() {\n  logGroup('Test Results', 'results');\n\n  if (this.stats.failures > 0) {\n    log(pluralizedStat(this.stats.failures, 'failing'), 'failing');\n  }\n  if (this.stats.pending > 0) {\n    log(pluralizedStat(this.stats.pending, 'pending'), 'pending');\n  }\n  log(pluralizedStat(this.stats.passes, 'passing'));\n\n  if (!this.stats.failures) {\n    log('test suite passed', 'passing');\n  }\n  log('Evaluated ' + this.stats.tests + ' tests in ' + this.stats.duration + 'ms.');\n  logGroupEnd();\n};\n\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * WCT-specific behavior on top of Mocha's default HTML reporter.\n *\n * @param {!Mocha.Runner} runner The runner that is being reported on.\n */\nfunction HTML(runner) {\n  var output = document.createElement('div');\n  output.id = 'mocha';\n  document.body.appendChild(output);\n\n  runner.on('suite', function(test) {\n    this.total = runner.total;\n  }.bind(this));\n\n  Mocha.reporters.HTML.call(this, runner);\n}\n\n// Woo! What a hack. This just saves us from adding a bunch of complexity around\n// style loading.\nvar style = document.createElement('style');\nstyle.textContent = 'html, body {' +\n                    '  position: relative;' +\n                    '  height: 100%;' +\n                    '  width:  100%;' +\n                    '  min-width: 900px;' +\n                    '}' +\n                    '#mocha, #subsuites {' +\n                    '  height: 100%;' +\n                    '  position: absolute;' +\n                    '  top: 0;' +\n                    '}' +\n                    '#mocha {' +\n                    '  box-sizing: border-box;' +\n                    '  margin: 0 !important;' +\n                    '  overflow-y: auto;' +\n                    '  padding: 60px 20px;' +\n                    '  right: 0;' +\n                    '  left: 500px;' +\n                    '}' +\n                    '#subsuites {' +\n                    '  -ms-flex-direction: column;' +\n                    '  -webkit-flex-direction: column;' +\n                    '  display: -ms-flexbox;' +\n                    '  display: -webkit-flex;' +\n                    '  display: flex;' +\n                    '  flex-direction: column;' +\n                    '  left: 0;' +\n                    '  width: 500px;' +\n                    '}' +\n                    '#subsuites .subsuite {' +\n                    '  border: 0;' +\n                    '  width: 100%;' +\n                    '  height: 100%;' +\n                    '}' +\n                    '#mocha .test.pass .duration {' +\n                    '  color: #555 !important;' +\n                    '}';\ndocument.head.appendChild(style);\n\nvar STACKY_CONFIG = {\n  indent: '  ',\n  locationStrip: [\n    /^https?:\\/\\/[^\\/]+/,\n    /\\?.*$/,\n  ],\n  filter: function(line) {\n    return line.location.match(/\\/web-component-tester\\/[^\\/]+(\\?.*)?$/);\n  },\n};\n\n// https://github.com/visionmedia/mocha/blob/master/lib/runner.js#L36-46\nvar MOCHA_EVENTS = [\n  'start',\n  'end',\n  'suite',\n  'suite end',\n  'test',\n  'test end',\n  'hook',\n  'hook end',\n  'pass',\n  'fail',\n  'pending',\n  'childRunner end'\n];\n\n// Until a suite has loaded, we assume this many tests in it.\nvar ESTIMATED_TESTS_PER_SUITE = 3;\n\n/**\n * A Mocha-like reporter that combines the output of multiple Mocha suites.\n *\n * @param {number} numSuites The number of suites that will be run, in order to\n *     estimate the total number of tests that will be performed.\n * @param {!Array.<!Mocha.reporters.Base>} reporters The set of reporters that\n *     should receive the unified event stream.\n * @param {MultiReporter} parent The parent reporter, if present.\n */\nfunction MultiReporter(numSuites, reporters, parent) {\n  this.reporters = reporters.map(function(reporter) {\n    return new reporter(this);\n  }.bind(this));\n\n  this.parent = parent;\n  this.basePath = parent && parent.basePath || basePath(window.location);\n\n  this.total = numSuites * ESTIMATED_TESTS_PER_SUITE;\n  // Mocha reporters assume a stream of events, so we have to be careful to only\n  // report on one runner at a time...\n  this.currentRunner = null;\n  // ...while we buffer events for any other active runners.\n  this.pendingEvents = [];\n\n  this.emit('start');\n}\n\n/**\n * @param {!Location|string} location The location this reporter represents.\n * @return {!Mocha.reporters.Base} A reporter-like \"class\" for each child suite\n *     that should be passed to `mocha.run`.\n */\nMultiReporter.prototype.childReporter = function childReporter(location) {\n  var name = this.suiteTitle(location);\n  // The reporter is used as a constructor, so we can't depend on `this` being\n  // properly bound.\n  var self = this;\n  function reporter(runner) {\n    runner.name = name;\n    self.bindChildRunner(runner);\n  }\n  reporter.title = name;\n  return reporter;\n};\n\n/** Must be called once all runners have finished. */\nMultiReporter.prototype.done = function done() {\n  this.complete = true;\n  this.flushPendingEvents();\n  this.emit('end');\n};\n\n/**\n * Emit a top level test that is not part of any suite managed by this reporter.\n *\n * Helpful for reporting on global errors, loading issues, etc.\n *\n * @param {string} title The title of the test.\n * @param {*} opt_error An error associated with this test. If falsy, test is\n *     considered to be passing.\n * @param {string} opt_suiteTitle Title for the suite that's wrapping the test.\n * @param {?boolean} opt_estimated If this test was included in the original\n *     estimate of `numSuites`.\n */\nMultiReporter.prototype.emitOutOfBandTest = function emitOutOfBandTest(title, opt_error, opt_suiteTitle, opt_estimated) {\n  debug('MultiReporter#emitOutOfBandTest(', arguments, ')');\n  var root = new Mocha.Suite();\n  root.title = opt_suiteTitle || '';\n  var test = new Mocha.Test(title, function() {\n  });\n  test.parent = root;\n  test.state  = opt_error ? 'failed' : 'passed';\n  test.err    = opt_error;\n\n  if (!opt_estimated) {\n    this.total = this.total + ESTIMATED_TESTS_PER_SUITE;\n  }\n\n  var runner = {total: 1};\n  this.proxyEvent('start', runner);\n  this.proxyEvent('suite', runner, root);\n  this.proxyEvent('test', runner, test);\n  if (opt_error) {\n    this.proxyEvent('fail', runner, test, opt_error);\n  } else {\n    this.proxyEvent('pass', runner, test);\n  }\n  this.proxyEvent('test end', runner, test);\n  this.proxyEvent('suite end', runner, root);\n  this.proxyEvent('end', runner);\n};\n\n/**\n * @param {!Location|string} location\n * @return {string}\n */\nMultiReporter.prototype.suiteTitle = function suiteTitle(location) {\n  var path = relativeLocation(location, this.basePath);\n  path = cleanLocation(path);\n  return path;\n};\n\n// Internal Interface\n\n/** @param {!Mocha.runners.Base} runner The runner to listen to events for. */\nMultiReporter.prototype.bindChildRunner = function bindChildRunner(runner) {\n  MOCHA_EVENTS.forEach(function(eventName) {\n    runner.on(eventName, this.proxyEvent.bind(this, eventName, runner));\n  }.bind(this));\n};\n\n/**\n * Evaluates an event fired by `runner`, proxying it forward or buffering it.\n *\n * @param {string} eventName\n * @param {!Mocha.runners.Base} runner The runner that emitted this event.\n * @param {...*} var_args Any additional data passed as part of the event.\n */\nMultiReporter.prototype.proxyEvent = function proxyEvent(eventName, runner, var_args) {\n  var extraArgs = Array.prototype.slice.call(arguments, 2);\n  if (this.complete) {\n    console.warn('out of order Mocha event for ' + runner.name + ':', eventName, extraArgs);\n    return;\n  }\n\n  if (this.currentRunner && runner !== this.currentRunner) {\n    this.pendingEvents.push(arguments);\n    return;\n  }\n  debug('MultiReporter#proxyEvent(', arguments, ')');\n\n  // This appears to be a Mocha bug: Tests failed by passing an error to their\n  // done function don't set `err` properly.\n  //\n  // TODO(nevir): Track down.\n  if (eventName === 'fail' && !extraArgs[0].err) {\n    extraArgs[0].err = extraArgs[1];\n  }\n\n  if (eventName === 'start') {\n    this.onRunnerStart(runner);\n  } else if (eventName === 'end') {\n    this.onRunnerEnd(runner);\n  } else {\n    this.cleanEvent(eventName, runner, extraArgs);\n    this.emit.apply(this, [eventName].concat(extraArgs));\n  }\n};\n\n/**\n * Cleans or modifies an event if needed.\n *\n * @param {string} eventName\n * @param {!Mocha.runners.Base} runner The runner that emitted this event.\n * @param {!Array.<*>} extraArgs\n */\nMultiReporter.prototype.cleanEvent = function cleanEvent(eventName, runner, extraArgs) {\n  // Suite hierarchy\n  if (extraArgs[0]) {\n    extraArgs[0] = this.showRootSuite(extraArgs[0]);\n  }\n\n  // Normalize errors\n  if (eventName === 'fail') {\n    extraArgs[1] = Stacky.normalize(extraArgs[1], STACKY_CONFIG);\n  }\n  if (extraArgs[0] && extraArgs[0].err) {\n    extraArgs[0].err = Stacky.normalize(extraArgs[0].err, STACKY_CONFIG);\n  }\n};\n\n/**\n * We like to show the root suite's title, which requires a little bit of\n * trickery in the suite hierarchy.\n *\n * @param {!Mocha.Runnable} node\n */\nMultiReporter.prototype.showRootSuite = function showRootSuite(node) {\n  var leaf = node = Object.create(node);\n  while (node && node.parent) {\n    var wrappedParent = Object.create(node.parent);\n    node.parent = wrappedParent;\n    node = wrappedParent;\n  }\n  node.root = false;\n\n  return leaf;\n};\n\n/** @param {!Mocha.runners.Base} runner */\nMultiReporter.prototype.onRunnerStart = function onRunnerStart(runner) {\n  debug('MultiReporter#onRunnerStart:', runner.name);\n  this.total = this.total - ESTIMATED_TESTS_PER_SUITE + runner.total;\n  this.currentRunner = runner;\n};\n\n/** @param {!Mocha.runners.Base} runner */\nMultiReporter.prototype.onRunnerEnd = function onRunnerEnd(runner) {\n  debug('MultiReporter#onRunnerEnd:', runner.name);\n  this.currentRunner = null;\n  this.flushPendingEvents();\n};\n\n/**\n * Flushes any buffered events and runs them through `proxyEvent`. This will\n * loop until all buffered runners are complete, or we have run out of buffered\n * events.\n */\nMultiReporter.prototype.flushPendingEvents = function flushPendingEvents() {\n  var events = this.pendingEvents;\n  this.pendingEvents = [];\n  events.forEach(function(eventArgs) {\n    this.proxyEvent.apply(this, eventArgs);\n  }.bind(this));\n};\n\nvar ARC_OFFSET = 0; // start at the right.\nvar ARC_WIDTH  = 6;\n\n/**\n * A Mocha reporter that updates the document's title and favicon with\n * at-a-glance stats.\n *\n * @param {!Mocha.Runner} runner The runner that is being reported on.\n */\nfunction Title(runner) {\n  Mocha.reporters.Base.call(this, runner);\n\n  runner.on('test end', this.report.bind(this));\n}\n\n/** Reports current stats via the page title and favicon. */\nTitle.prototype.report = function report() {\n  this.updateTitle();\n  this.updateFavicon();\n};\n\n/** Updates the document title with a summary of current stats. */\nTitle.prototype.updateTitle = function updateTitle() {\n  if (this.stats.failures > 0) {\n    document.title = pluralizedStat(this.stats.failures, 'failing');\n  } else {\n    document.title = pluralizedStat(this.stats.passes, 'passing');\n  }\n};\n\n/**\n * Draws an arc for the favicon status, relative to the total number of tests.\n *\n * @param {!CanvasRenderingContext2D} context\n * @param {number} total\n * @param {number} start\n * @param {number} length\n * @param {string} color\n */\nfunction drawFaviconArc(context, total, start, length, color) {\n  var arcStart = ARC_OFFSET + Math.PI * 2 * (start / total);\n  var arcEnd   = ARC_OFFSET + Math.PI * 2 * ((start + length) / total);\n\n  context.beginPath();\n  context.strokeStyle = color;\n  context.lineWidth   = ARC_WIDTH;\n  context.arc(16, 16, 16 - ARC_WIDTH / 2, arcStart, arcEnd);\n  context.stroke();\n}\n\n/** Updates the document's favicon w/ a summary of current stats. */\nTitle.prototype.updateFavicon = function updateFavicon() {\n  var canvas = document.createElement('canvas');\n  canvas.height = canvas.width = 32;\n  var context = canvas.getContext('2d');\n\n  var passing = this.stats.passes;\n  var pending = this.stats.pending;\n  var failing = this.stats.failures;\n  var total   = Math.max(this.runner.total, passing + pending + failing);\n  drawFaviconArc(context, total, 0,                 passing, '#0e9c57');\n  drawFaviconArc(context, total, passing,           pending, '#f3b300');\n  drawFaviconArc(context, total, pending + passing, failing, '#ff5621');\n\n  this.setFavicon(canvas.toDataURL());\n};\n\n/** Sets the current favicon by URL. */\nTitle.prototype.setFavicon = function setFavicon(url) {\n  var current = document.head.querySelector('link[rel=\"icon\"]');\n  if (current) {\n    document.head.removeChild(current);\n  }\n\n  var link = document.createElement('link');\n  link.rel = 'icon';\n  link.type = 'image/x-icon';\n  link.href = url;\n  link.setAttribute('sizes', '32x32');\n  document.head.appendChild(link);\n};\n\n/**\n * @param {CLISocket} socket The CLI socket, if present.\n * @param {MultiReporter} parent The parent reporter, if present.\n * @return {!Array.<!Mocha.reporters.Base} The reporters that should be used.\n */\nfunction determineReporters(socket, parent) {\n  // Parents are greedy.\n  if (parent) {\n    return [parent.childReporter(window.location)];\n  }\n\n  // Otherwise, we get to run wild without any parental supervision!\n  var reporters = [Title, Console];\n\n  if (socket) {\n    reporters.push(function(runner) {\n      socket.observe(runner);\n    });\n  }\n\n  if (htmlSuites$1.length > 0 || jsSuites$1.length > 0) {\n    reporters.push(HTML);\n  }\n\n  return reporters;\n}\n\n/**\n * Yeah, hideous, but this allows us to be loaded before Mocha, which is handy.\n */\nfunction injectMocha(Mocha) {\n  _injectPrototype(Console, Mocha.reporters.Base.prototype);\n  _injectPrototype(HTML,    Mocha.reporters.HTML.prototype);\n  // Mocha doesn't expose its `EventEmitter` shim directly, so:\n  _injectPrototype(MultiReporter,   Object.getPrototypeOf(Mocha.Runner.prototype));\n}\n\nfunction _injectPrototype(klass, prototype) {\n  var newPrototype = Object.create(prototype);\n  // Only support\n  Object.keys(klass.prototype).forEach(function(key) {\n    newPrototype[key] = klass.prototype[key];\n  });\n\n  klass.prototype = newPrototype;\n}\n\n/**\n * Loads all environment scripts ...synchronously ...after us.\n */\nfunction loadSync() {\n  debug('Loading environment scripts:');\n  var a11ySuite = 'web-component-tester/data/a11ySuite.js';\n  var scripts = get('environmentScripts');\n  var a11ySuiteWillBeLoaded = window.__generatedByWct || scripts.indexOf(a11ySuite) > -1;\n  if (!a11ySuiteWillBeLoaded) {\n    // wct is running as a bower dependency, load a11ySuite from data/\n    scripts.push(a11ySuite);\n  }\n  scripts.forEach(function(path) {\n    var url = expandUrl(path, get('root'));\n    debug('Loading environment script:', url);\n    // Synchronous load.\n    document.write('<script src=\"' + encodeURI(url) + '\"></script>'); // jshint ignore:line\n  });\n  debug('Environment scripts loaded');\n\n  var imports = get('environmentImports');\n  imports.forEach(function(path) {\n    var url = expandUrl(path, get('root'));\n    debug('Loading environment import:', url);\n    // Synchronous load.\n    document.write('<link rel=\"import\" href=\"' + encodeURI(url) + '\">'); // jshint ignore:line\n  });\n  if (imports.length > 0) {\n    // NOTE: In Chrome57 test-fixture elements in the document don't get upgraded when the import\n    // is dynamically appended. We stop the parser from continuing to parse the document by\n    // appending an \"empty\" script. This gives time to customElements for upgrading elements.\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=701601\n    document.write('<script>void(0)</script>'); // jshint ignore:line\n  }\n  debug('Environment imports loaded');\n}\n\n/**\n * We have some hard dependencies on things that should be loaded via\n * `environmentScripts`, so we assert that they're present here; and do any\n * post-facto setup.\n */\nfunction ensureDependenciesPresent() {\n  _ensureMocha();\n  _checkChai();\n}\n\nfunction _ensureMocha() {\n  var Mocha = window.Mocha;\n  if (!Mocha) {\n    throw new Error('WCT requires Mocha. Please ensure that it is present in WCT.environmentScripts, or that you load it before loading web-component-tester/browser.js');\n  }\n  injectMocha(Mocha);\n  // Magic loading of mocha's stylesheet\n  var mochaPrefix = scriptPrefix('mocha.js');\n  // only load mocha stylesheet for the test runner output\n  // Not the end of the world, if it doesn't load.\n  if (mochaPrefix && window.top === window.self) {\n    loadStyle(mochaPrefix + 'mocha.css');\n  }\n}\n\nfunction _checkChai() {\n  if (!window.chai) {\n    debug('Chai not present; not registering shorthands');\n    return;\n  }\n\n  window.assert = window.chai.assert;\n  window.expect = window.chai.expect;\n}\n\n// We may encounter errors during initialization (for example, syntax errors in\n// a test file). Hang onto those (and more) until we are ready to report them.\nvar globalErrors = [];\n\n/**\n * Hook the environment to pick up on global errors.\n */\nfunction listenForErrors() {\n  window.addEventListener('error', function(event) {\n    globalErrors.push(event.error);\n  });\n\n  // Also, we treat `console.error` as a test failure. Unless you prefer not.\n  var origConsole = console;\n  var origError   = console.error;\n  console.error = function wctShimmedError() {\n    origError.apply(origConsole, arguments);\n    if (get('trackConsoleError')) {\n      throw 'console.error: ' + Array.prototype.join.call(arguments, ' ');\n    }\n  };\n}\n\nvar interfaceExtensions = [];\n\n/**\n * Registers an extension that extends the global `Mocha` implementation\n * with new helper methods. These helper methods will be added to the `window`\n * when tests run for both BDD and TDD interfaces.\n */\nfunction extendInterfaces(helperName, helperFactory) {\n  interfaceExtensions.push(function() {\n    var Mocha = window.Mocha;\n    // For all Mocha interfaces (probably just TDD and BDD):\n    Object.keys(Mocha.interfaces).forEach(function(interfaceName) {\n      // This is the original callback that defines the interface (TDD or BDD):\n      var originalInterface = Mocha.interfaces[interfaceName];\n      // This is the name of the \"teardown\" or \"afterEach\" property for the\n      // current interface:\n      var teardownProperty = interfaceName === 'tdd' ? 'teardown' : 'afterEach';\n      // The original callback is monkey patched with a new one that appends to\n      // the global context however we want it to:\n      Mocha.interfaces[interfaceName] = function(suite) {\n        // Call back to the original callback so that we get the base interface:\n        originalInterface.apply(this, arguments);\n        // Register a listener so that we can further extend the base interface:\n        suite.on('pre-require', function(context, file, mocha) {\n          // Capture a bound reference to the teardown function as a convenience:\n          var teardown = context[teardownProperty].bind(context);\n          // Add our new helper to the testing context. The helper is generated\n          // by a factory method that receives the context, the teardown function\n          // and the interface name and returns the new method to be added to\n          // that context:\n          context[helperName] = helperFactory(context, teardown, interfaceName);\n        });\n      };\n    });\n  });\n}\n\n/**\n * Applies any registered interface extensions. The extensions will be applied\n * as many times as this function is called, so don't call it more than once.\n */\nfunction applyExtensions() {\n  interfaceExtensions.forEach(function(applyExtension) {\n    applyExtension();\n  });\n}\n\nextendInterfaces('fixture', function(context, teardown) {\n\n  // Return context.fixture if it is already a thing, for backwards\n  // compatibility with `test-fixture-mocha.js`:\n  return context.fixture || function fixture(fixtureId, model) {\n\n    // Automatically register a teardown callback that will restore the\n    // test-fixture:\n    teardown(function() {\n      document.getElementById(fixtureId).restore();\n    });\n\n    // Find the test-fixture with the provided ID and create it, returning\n    // the results:\n    return document.getElementById(fixtureId).create(model);\n  };\n});\n\n/**\n * stub\n *\n * The stub addon allows the tester to partially replace the implementation of\n * an element with some custom implementation. Usage example:\n *\n * beforeEach(function() {\n *   stub('x-foo', {\n *     attached: function() {\n *       // Custom implementation of the `attached` method of element `x-foo`..\n *     },\n *     otherMethod: function() {\n *       // More custom implementation..\n *     },\n *     // etc..\n *   });\n * });\n */\nextendInterfaces('stub', function(context, teardown) {\n\n  return function stub(tagName, implementation) {\n    // Find the prototype of the element being stubbed:\n    var proto = document.createElement(tagName).constructor.prototype;\n\n    // For all keys in the implementation to stub with..\n    var keys = Object.keys(implementation);\n    keys.forEach(function(key) {\n      // Stub the method on the element prototype with Sinon:\n      sinon.stub(proto, key, implementation[key]);\n    });\n\n    // After all tests..\n    teardown(function() {\n      // For all of the keys in the implementation we stubbed..\n      keys.forEach(function(key) {\n        // Restore the stub:\n        if (proto[key].isSinonProxy) {\n          proto[key].restore();\n        }\n      });\n    });\n  };\n});\n\n// replacement map stores what should be\nvar replacements = {};\nvar replaceTeardownAttached = false;\n\n/**\n * replace\n *\n * The replace addon allows the tester to replace all usages of one element with\n * another element within all Polymer elements created within the time span of\n * the test. Usage example:\n *\n * beforeEach(function() {\n *   replace('x-foo').with('x-fake-foo');\n * });\n *\n * All annotations and attributes will be set on the placement element the way\n * they were set for the original element.\n */\nextendInterfaces('replace', function(context, teardown) {\n  return function replace(oldTagName) {\n    return {\n      with: function(tagName) {\n        // Standardizes our replacements map\n        oldTagName = oldTagName.toLowerCase();\n        tagName = tagName.toLowerCase();\n\n        replacements[oldTagName] = tagName;\n\n        // If the function is already a stub, restore it to original\n        if (Polymer.Base.instanceTemplate.isSinonProxy) {\n          return;\n        }\n\n        // Keep a reference to the original `Polymer.Base.instanceTemplate`\n        // implementation for later:\n        var originalInstanceTemplate = Polymer.Base.instanceTemplate;\n\n        // Use Sinon to stub `Polymer.Base.instanceTemplate`:\n        sinon.stub(Polymer.Base, 'instanceTemplate', function(template) {\n          var origContent = template._content || template.content;\n          var templateClone = document.createElement('template');\n          var content = templateClone.content;\n          var inertDoc = content.ownerDocument;\n\n          // imports node from inertDoc which holds inert nodes.\n          templateClone.content.appendChild(inertDoc.importNode(origContent, true));\n\n          // optional arguments are not optional on IE.\n          var nodeIterator = document.createNodeIterator(content,\n              NodeFilter.SHOW_ELEMENT, null, true);\n          var node;\n\n          // Traverses the tree. A recently-replaced node will be put next, so\n          // if a node is replaced, it will be checked if it needs to be\n          // replaced again.\n          while (node = nodeIterator.nextNode()) {\n            var currentTagName = node.tagName.toLowerCase();\n\n            if (replacements.hasOwnProperty(currentTagName)) {\n              currentTagName = replacements[currentTagName];\n\n              // find the final tag name.\n              while (replacements[currentTagName]) {\n                currentTagName = replacements[currentTagName];\n              }\n\n              // Create a replacement:\n              var replacement = document.createElement(currentTagName);\n\n              // For all attributes in the original node..\n              for (var index = 0; index < node.attributes.length; ++index) {\n                // Set that attribute on the replacement:\n                replacement.setAttribute(\n                  node.attributes[index].name, node.attributes[index].value);\n              }\n\n              // Replace the original node with the replacement node:\n              node.parentNode.replaceChild(replacement, node);\n            }\n          }\n\n          return originalInstanceTemplate.call(this, templateClone);\n        });\n\n        if (!replaceTeardownAttached) {\n          // After each test...\n          teardown(function() {\n            replaceTeardownAttached = true;\n            // Restore the stubbed version of `Polymer.Base.instanceTemplate`:\n            if (Polymer.Base.instanceTemplate.isSinonProxy) {\n              Polymer.Base.instanceTemplate.restore();\n            }\n\n            // Empty the replacement map\n            replacements = {};\n          });\n        }\n      }\n    };\n  };\n});\n\n// Mocha global helpers, broken out by testing method.\n//\n// Keys are the method for a particular interface; values are their analog in\n// the opposite interface.\nvar MOCHA_EXPORTS = {\n  // https://github.com/visionmedia/mocha/blob/master/lib/interfaces/tdd.js\n  tdd: {\n    'setup':         '\"before\"',\n    'teardown':      '\"after\"',\n    'suiteSetup':    '\"beforeEach\"',\n    'suiteTeardown': '\"afterEach\"',\n    'suite':         '\"describe\" or \"context\"',\n    'test':          '\"it\" or \"specify\"',\n  },\n  // https://github.com/visionmedia/mocha/blob/master/lib/interfaces/bdd.js\n  bdd: {\n    'before':     '\"setup\"',\n    'after':      '\"teardown\"',\n    'beforeEach': '\"suiteSetup\"',\n    'afterEach':  '\"suiteTeardown\"',\n    'describe':   '\"suite\"',\n    'context':    '\"suite\"',\n    'xdescribe':  '\"suite.skip\"',\n    'xcontext':   '\"suite.skip\"',\n    'it':         '\"test\"',\n    'xit':        '\"test.skip\"',\n    'specify':    '\"test\"',\n    'xspecify':   '\"test.skip\"',\n  },\n};\n\n/**\n * Exposes all Mocha methods up front, configuring and running mocha\n * automatically when you call them.\n *\n * The assumption is that it is a one-off (sub-)suite of tests being run.\n */\nfunction stubInterfaces() {\n  Object.keys(MOCHA_EXPORTS).forEach(function(ui) {\n    Object.keys(MOCHA_EXPORTS[ui]).forEach(function(key) {\n      window[key] = function wrappedMochaFunction() {\n        _setupMocha(ui, key, MOCHA_EXPORTS[ui][key]);\n        if (!window[key] || window[key] === wrappedMochaFunction) {\n          throw new Error('Expected mocha.setup to define ' + key);\n        }\n        window[key].apply(window, arguments);\n      };\n    });\n  });\n}\n\n// Whether we've called `mocha.setup`\nvar _mochaIsSetup = false;\n\n/**\n * @param {string} ui Sets up mocha to run `ui`-style tests.\n * @param {string} key The method called that triggered this.\n * @param {string} alternate The matching method in the opposite interface.\n */\nfunction _setupMocha(ui, key, alternate) {\n  var mochaOptions = get('mochaOptions');\n  if (mochaOptions.ui && mochaOptions.ui !== ui) {\n    var message = 'Mixing ' + mochaOptions.ui + ' and ' + ui + ' Mocha styles is not supported. ' +\n                  'You called \"' + key + '\". Did you mean ' + alternate + '?';\n    throw new Error(message);\n  }\n  if (_mochaIsSetup) return;\n\n  applyExtensions();\n  mochaOptions.ui = ui;\n  mocha.setup(mochaOptions);  // Note that the reporter is configured in run.js.\n}\n\nvar SOCKETIO_ENDPOINT = window.location.protocol + '//' + window.location.host;\nvar SOCKETIO_LIBRARY  = SOCKETIO_ENDPOINT + '/socket.io/socket.io.js';\n\n/**\n * A socket for communication between the CLI and browser runners.\n *\n * @param {string} browserId An ID generated by the CLI runner.\n * @param {!io.Socket} socket The socket.io `Socket` to communicate over.\n */\nfunction CLISocket(browserId, socket) {\n  this.browserId = browserId;\n  this.socket    = socket;\n}\n\n/**\n * @param {!Mocha.Runner} runner The Mocha `Runner` to observe, reporting\n *     interesting events back to the CLI runner.\n */\nCLISocket.prototype.observe = function observe(runner) {\n  this.emitEvent('browser-start', {\n    url: window.location.toString(),\n  });\n\n  // We only emit a subset of events that we care about, and follow a more\n  // general event format that is hopefully applicable to test runners beyond\n  // mocha.\n  //\n  // For all possible mocha events, see:\n  // https://github.com/visionmedia/mocha/blob/master/lib/runner.js#L36\n  runner.on('test', function(test) {\n    this.emitEvent('test-start', {test: getTitles(test)});\n  }.bind(this));\n\n  runner.on('test end', function(test) {\n    this.emitEvent('test-end', {\n      state:    getState(test),\n      test:     getTitles(test),\n      duration: test.duration,\n      error:    test.err,\n    });\n  }.bind(this));\n\n  runner.on('fail', function(test, err) {\n    // fail the test run if we catch errors outside of a test function\n    if (test.type !== 'test') {\n      this.emitEvent('browser-fail', 'Error thrown outside of test function: ' + err.stack);\n    }\n  }.bind(this));\n\n  runner.on('childRunner start', function(childRunner) {\n    this.emitEvent('sub-suite-start', childRunner.share);\n  }.bind(this));\n\n  runner.on('childRunner end', function(childRunner) {\n    this.emitEvent('sub-suite-end', childRunner.share);\n  }.bind(this));\n\n  runner.on('end', function() {\n    this.emitEvent('browser-end');\n  }.bind(this));\n};\n\n/**\n * @param {string} event The name of the event to fire.\n * @param {*} data Additional data to pass with the event.\n */\nCLISocket.prototype.emitEvent = function emitEvent(event, data) {\n  this.socket.emit('client-event', {\n    browserId: this.browserId,\n    event:     event,\n    data:      data,\n  });\n};\n\n/**\n * Builds a `CLISocket` if we are within a CLI-run environment; short-circuits\n * otherwise.\n *\n * @param {function(*, CLISocket)} done Node-style callback.\n */\nCLISocket.init = function init(done) {\n  var browserId = getParam('cli_browser_id');\n  if (!browserId) return done();\n  // Only fire up the socket for root runners.\n  if (ChildRunner.current()) return done();\n\n  loadScript(SOCKETIO_LIBRARY, function(error) {\n    if (error) return done(error);\n\n    var socket = io(SOCKETIO_ENDPOINT);\n    socket.on('error', function(error) {\n      socket.off();\n      done(error);\n    });\n\n    socket.on('connect', function() {\n      socket.off();\n      done(null, new CLISocket(browserId, socket));\n    });\n  });\n};\n\n// Misc Utility\n\n/**\n * @param {!Mocha.Runnable} runnable The test or suite to extract titles from.\n * @return {!Array.<string>} The titles of the runnable and its parents.\n */\nfunction getTitles(runnable) {\n  var titles = [];\n  while (runnable && !runnable.root && runnable.title) {\n    titles.unshift(runnable.title);\n    runnable = runnable.parent;\n  }\n  return titles;\n}\n\n/**\n * @param {!Mocha.Runnable} runnable\n * @return {string}\n */\nfunction getState(runnable) {\n  if (runnable.state === 'passed') {\n    return 'passing';\n  } else if (runnable.state == 'failed') {\n    return 'failing';\n  } else if (runnable.pending) {\n    return 'pending';\n  } else {\n    return 'unknown';\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n// Make sure that we use native timers, in case they're being stubbed out.\nvar setInterval           = window.setInterval;           // jshint ignore:line\nvar setTimeout$1            = window.setTimeout;            // jshint ignore:line\nvar requestAnimationFrame = window.requestAnimationFrame; // jshint ignore:line\n\n/**\n * Runs `stepFn`, catching any error and passing it to `callback` (Node-style).\n * Otherwise, calls `callback` with no arguments on success.\n *\n * @param {function()} callback\n * @param {function()} stepFn\n */\nwindow.safeStep = function safeStep(callback, stepFn) {\n  var err;\n  try {\n    stepFn();\n  } catch (error) {\n    err = error;\n  }\n  callback(err);\n};\n\n/**\n * Runs your test at declaration time (before Mocha has begun tests). Handy for\n * when you need to test document initialization.\n *\n * Be aware that any errors thrown asynchronously cannot be tied to your test.\n * You may want to catch them and pass them to the done event, instead. See\n * `safeStep`.\n *\n * @param {string} name The name of the test.\n * @param {function(?function())} testFn The test function. If an argument is\n *     accepted, the test will be treated as async, just like Mocha tests.\n */\nwindow.testImmediate = function testImmediate(name, testFn) {\n  if (testFn.length > 0) {\n    return testImmediateAsync(name, testFn);\n  }\n\n  var err;\n  try {\n    testFn();\n  } catch (error) {\n    err = error;\n  }\n\n  test(name, function(done) {\n    done(err);\n  });\n};\n\n/**\n * An async-only variant of `testImmediate`.\n *\n * @param {string} name\n * @param {function(?function())} testFn\n */\nwindow.testImmediateAsync = function testImmediateAsync(name, testFn) {\n  var testComplete = false;\n  var err;\n\n  test(name, function(done) {\n    var intervalId = setInterval(function() {\n      if (!testComplete) return;\n      clearInterval(intervalId);\n      done(err);\n    }, 10);\n  });\n\n  try {\n    testFn(function(error) {\n      if (error) err = error;\n      testComplete = true;\n    });\n  } catch (error) {\n    err = error;\n    testComplete = true;\n  }\n};\n\n/**\n * Triggers a flush of any pending events, observations, etc and calls you back\n * after they have been processed.\n *\n * @param {function()} callback\n */\nwindow.flush = function flush(callback) {\n  // Ideally, this function would be a call to Polymer.dom.flush, but that doesn't\n  // support a callback yet (https://github.com/Polymer/polymer-dev/issues/851),\n  // ...and there's cross-browser flakiness to deal with.\n\n  // Make sure that we're invoking the callback with no arguments so that the\n  // caller can pass Mocha callbacks, etc.\n  var done = function done() { callback(); };\n\n  // Because endOfMicrotask is flaky for IE, we perform microtask checkpoints\n  // ourselves (https://github.com/Polymer/polymer-dev/issues/114):\n  var isIE = navigator.appName == 'Microsoft Internet Explorer';\n  if (isIE && window.Platform && window.Platform.performMicrotaskCheckpoint) {\n    var reallyDone = done;\n    done = function doneIE() {\n      Platform.performMicrotaskCheckpoint();\n      setTimeout$1(reallyDone, 0);\n    };\n  }\n\n  // Everyone else gets a regular flush.\n  var scope;\n  if (window.Polymer && window.Polymer.dom && window.Polymer.dom.flush) {\n    scope = window.Polymer.dom;\n  } else if (window.Polymer && window.Polymer.flush) {\n    scope = window.Polymer;\n  } else if (window.WebComponents && window.WebComponents.flush) {\n    scope = window.WebComponents;\n  }\n  if (scope) {\n    scope.flush();\n  }\n\n  // Ensure that we are creating a new _task_ to allow all active microtasks to\n  // finish (the code you're testing may be using endOfMicrotask, too).\n  setTimeout$1(done, 0);\n};\n\n/**\n * Advances a single animation frame.\n *\n * Calls `flush`, `requestAnimationFrame`, `flush`, and `callback` sequentially\n * @param {function()} callback\n */\nwindow.animationFrameFlush = function animationFrameFlush(callback) {\n  flush(function() {\n    requestAnimationFrame(function() {\n      flush(callback);\n    });\n  });\n};\n\n/**\n * DEPRECATED: Use `flush`.\n * @param {function} callback\n */\nwindow.asyncPlatformFlush = function asyncPlatformFlush(callback) {\n  console.warn('asyncPlatformFlush is deprecated in favor of the more terse flush()');\n  return window.flush(callback);\n};\n\n/**\n *\n */\nwindow.waitFor = function waitFor(fn, next, intervalOrMutationEl, timeout, timeoutTime) {\n  timeoutTime = timeoutTime || Date.now() + (timeout || 1000);\n  intervalOrMutationEl = intervalOrMutationEl || 32;\n  try {\n    fn();\n  } catch (e) {\n    if (Date.now() > timeoutTime) {\n      throw e;\n    } else {\n      if (isNaN(intervalOrMutationEl)) {\n        intervalOrMutationEl.onMutation(intervalOrMutationEl, function() {\n          waitFor(fn, next, intervalOrMutationEl, timeout, timeoutTime);\n        });\n      } else {\n        setTimeout$1(function() {\n          waitFor(fn, next, intervalOrMutationEl, timeout, timeoutTime);\n        }, intervalOrMutationEl);\n      }\n      return;\n    }\n  }\n  next();\n};\n\n// You can configure WCT before it has loaded by assigning your custom\n// configuration to the global `WCT`.\nsetup(window.WCT);\n\n// Maybe some day we'll expose WCT as a module to whatever module registry you\n// are using (aka the UMD approach), or as an es6 module.\nvar WCT = window.WCT = {};\n// A generic place to hang data about the current suite. This object is reported\n// back via the `sub-suite-start` and `sub-suite-end` events.\nWCT.share = {};\n// Until then, we get to rely on it to expose parent runners to their children.\nWCT._ChildRunner = ChildRunner;\nWCT._config      = _config;\n\n\n// Public Interface\n\n/**\n * Loads suites of tests, supporting both `.js` and `.html` files.\n *\n * @param {!Array.<string>} files The files to load.\n */\nWCT.loadSuites = loadSuites;\n\n\n// Load Process\n\nlistenForErrors();\nstubInterfaces();\nloadSync();\n\n// Give any scripts on the page a chance to declare tests and muck with things.\ndocument.addEventListener('DOMContentLoaded', function() {\n  debug('DOMContentLoaded');\n\n  ensureDependenciesPresent();\n\n  // We need the socket built prior to building its reporter.\n  CLISocket.init(function(error, socket) {\n    if (error) throw error;\n\n    // Are we a child of another run?\n    var current = ChildRunner.current();\n    var parent  = current && current.parentScope.WCT._reporter;\n    debug('parentReporter:', parent);\n\n    var childSuites    = activeChildSuites();\n    var reportersToUse = determineReporters(socket, parent);\n    // +1 for any local tests.\n    var reporter = new MultiReporter(childSuites.length + 1, reportersToUse, parent);\n    WCT._reporter = reporter; // For environment/compatibility.js\n\n    // We need the reporter so that we can report errors during load.\n    loadJsSuites(reporter, function(error) {\n      // Let our parent know that we're about to start the tests.\n      if (current) current.ready(error);\n      if (error) throw error;\n\n      // Emit any errors we've encountered up til now\n      globalErrors.forEach(function onError(error) {\n        reporter.emitOutOfBandTest('Test Suite Initialization', error);\n      });\n\n      runSuites(reporter, childSuites, function(error) {\n        // Make sure to let our parent know that we're done.\n        if (current) current.done();\n        if (error) throw error;\n      });\n    });\n  });\n});\n\n}());\n//# sourceMappingURL=browser.js.map","/home/travis/build/npmtest/node-npmtest-web-component-tester/node_modules/web-component-tester/data/a11ySuite.js":"/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(Mocha, chai, axs) {\n\n  Object.keys(Mocha.interfaces).forEach(function(iface) {\n    var orig = Mocha.interfaces[iface];\n\n    Mocha.interfaces[iface] = function(suite) {\n      orig.apply(this, arguments);\n\n      var Suite = Mocha.Suite;\n      var Test = Mocha.Test;\n\n      suite.on('pre-require', function(context, file, mocha) {\n\n        /**\n          * Runs the Chrome Accessibility Developer Tools Audit against a test-fixture\n          *\n          * @param {String} fixtureId ID of the fixture element in the document to use\n          * @param {Array?} ignoredRules Array of rules to ignore for this suite\n          */\n        context.a11ySuite = function(fixtureId, ignoredRules) {\n          // capture a reference to the fixture element early\n          var fixtureElement = document.getElementById(fixtureId);\n          if (!fixtureElement) {\n            return;\n          }\n\n          // build an audit config to disable certain ignorable tests\n          var axsConfig = new axs.AuditConfiguration();\n          axsConfig.scope = document.body;\n          axsConfig.showUnsupportedRulesWarning = false;\n          axsConfig.auditRulesToIgnore = ignoredRules;\n\n          // build mocha suite\n          var a11ySuite = Suite.create(suite, 'A11y Audit - Fixture: ' + fixtureId);\n\n          // override the `eachTest` function to hackily create the tests\n          //\n          // eachTest is called right before test runs to calculate the total\n          // number of tests\n          a11ySuite.eachTest = function() {\n            // instantiate fixture\n            fixtureElement.create();\n\n            // run audit\n            var auditResults = axs.Audit.run(axsConfig);\n\n            // create tests for audit results\n            auditResults.forEach(function(result, index) {\n              // only show applicable tests\n              if (result.result !== 'NA') {\n                var title = result.rule.heading;\n                // fail test if audit result is FAIL\n                var error = result.result === 'FAIL' ? axs.Audit.accessibilityErrorMessage(result) : null;\n                var test = new Test(title, function() {\n                  if (error) {\n                    throw new Error(error);\n                  }\n                });\n                test.file = file;\n                a11ySuite.addTest(test);\n              }\n            });\n\n            // teardown fixture\n            fixtureElement.restore();\n\n            suite.eachTest.apply(a11ySuite, arguments);\n            this.eachTest = suite.eachTest;\n          };\n\n          return a11ySuite;\n        };\n      });\n    };\n  });\n\n  chai.use(function(chai, util) {\n    var Assertion = chai.Assertion;\n\n    // assert\n    chai.assert.a11yLabel = function(node, exp, msg){\n      new Assertion(node).to.have.a11yLabel(exp, msg);\n    };\n\n    // expect / should\n    Assertion.addMethod('a11yLabel', function(str, msg) {\n      if (msg) {\n        util.flag(this, 'message', msg);\n      }\n\n      var node = this._obj;\n\n      // obj must be a Node\n      new Assertion(node).to.be.instanceOf(Node);\n\n      // vind the text alternative with the help of accessibility dev tools\n      var textAlternative = axs.properties.findTextAlternatives(node, {});\n\n      this.assert(\n        textAlternative === str,\n        'expected #{this} to have text alternative #{exp} but got #{act}',\n        'expected #{this} to not have text alternative #{act}',\n        str,\n        textAlternative,\n        true\n      );\n    });\n  });\n})(window.Mocha, window.chai, window.axs);\n"}